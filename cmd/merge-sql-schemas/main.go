package main

import (
	"database/sql"
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"

	_ "github.com/mattn/go-sqlite3"
)

// main merges all SQL migration .up.sql files into a single consolidated
// schema by executing them against an in-memory SQLite database and dumping
// the resulting sqlite_master. This produces a clean schema file with no
// ALTERs that sqlc can parse correctly.
func main() {
	migrationsDir := "internal/db/migrations"
	outputFile := "internal/db/sqlc/schemas/generated_schema.sql"

	if err := run(migrationsDir, outputFile); err != nil {
		fmt.Fprintf(os.Stderr, "error: %v\n", err)
		os.Exit(1)
	}
}

// run executes all up migrations against an in-memory SQLite database and
// dumps the resulting schema to the output file.
func run(migrationsDir, outputFile string) error {
	// Open an in-memory SQLite database with FTS5 support.
	db, err := sql.Open("sqlite3", ":memory:")
	if err != nil {
		return fmt.Errorf("open in-memory db: %w", err)
	}
	defer db.Close()

	// Find and sort all .up.sql migration files.
	pattern := filepath.Join(migrationsDir, "*.up.sql")
	files, err := filepath.Glob(pattern)
	if err != nil {
		return fmt.Errorf("glob migrations: %w", err)
	}
	if len(files) == 0 {
		return fmt.Errorf("no migration files found in %s", migrationsDir)
	}
	sort.Strings(files)

	// Execute each migration against the in-memory database.
	for _, f := range files {
		sqlBytes, err := os.ReadFile(f)
		if err != nil {
			return fmt.Errorf("read %s: %w", f, err)
		}

		if _, err := db.Exec(string(sqlBytes)); err != nil {
			return fmt.Errorf("execute %s: %w", f, err)
		}

		fmt.Fprintf(os.Stderr, "applied: %s\n", filepath.Base(f))
	}

	// Dump the schema from sqlite_master.
	schema, err := dumpSchema(db)
	if err != nil {
		return fmt.Errorf("dump schema: %w", err)
	}

	// Ensure the output directory exists.
	if err := os.MkdirAll(filepath.Dir(outputFile), 0o755); err != nil {
		return fmt.Errorf("create output dir: %w", err)
	}

	// Write the consolidated schema.
	if err := os.WriteFile(outputFile, []byte(schema), 0o644); err != nil {
		return fmt.Errorf("write output: %w", err)
	}

	fmt.Fprintf(os.Stderr, "wrote: %s\n", outputFile)

	return nil
}

// dumpSchema queries sqlite_master and reconstructs all CREATE statements
// for tables, indexes, triggers, and virtual tables.
func dumpSchema(db *sql.DB) (string, error) {
	var b strings.Builder

	b.WriteString("-- Code generated by merge-sql-schemas. DO NOT EDIT.\n")
	b.WriteString("-- This file is the consolidated schema from all migrations.\n\n")

	// Dump tables first (excluding internal SQLite tables and FTS shadow
	// tables).
	if err := dumpObjects(db, &b, "table"); err != nil {
		return "", err
	}

	// Dump virtual tables (FTS5).
	if err := dumpVirtualTables(db, &b); err != nil {
		return "", err
	}

	// Dump indexes (excluding auto-generated ones).
	if err := dumpObjects(db, &b, "index"); err != nil {
		return "", err
	}

	// Dump triggers.
	if err := dumpObjects(db, &b, "trigger"); err != nil {
		return "", err
	}

	return b.String(), nil
}

// dumpObjects dumps all objects of the given type from sqlite_master.
func dumpObjects(db *sql.DB, b *strings.Builder, objType string) error {
	rows, err := db.Query(
		`SELECT name, sql FROM sqlite_master
		 WHERE type = ? AND sql IS NOT NULL
		 AND name NOT LIKE 'sqlite_%'
		 AND name NOT LIKE '%_fts_%'
		 ORDER BY name`,
		objType,
	)
	if err != nil {
		return fmt.Errorf("query %s: %w", objType, err)
	}
	defer rows.Close()

	for rows.Next() {
		var name, sqlStmt string
		if err := rows.Scan(&name, &sqlStmt); err != nil {
			return fmt.Errorf("scan %s: %w", objType, err)
		}

		// Skip FTS5 shadow tables, virtual tables (handled separately),
		// and internal indexes.
		if isFTSShadow(name) || strings.HasPrefix(name, "sqlite_") {
			continue
		}
		if objType == "table" && strings.Contains(
			strings.ToUpper(sqlStmt), "USING FTS5",
		) {
			continue
		}

		b.WriteString(sqlStmt)
		b.WriteString(";\n\n")
	}

	return rows.Err()
}

// dumpVirtualTables dumps FTS5 virtual table CREATE statements.
func dumpVirtualTables(db *sql.DB, b *strings.Builder) error {
	rows, err := db.Query(
		`SELECT name, sql FROM sqlite_master
		 WHERE type = 'table' AND sql LIKE '%USING fts5%'
		 ORDER BY name`,
	)
	if err != nil {
		return fmt.Errorf("query virtual tables: %w", err)
	}
	defer rows.Close()

	for rows.Next() {
		var name, sqlStmt string
		if err := rows.Scan(&name, &sqlStmt); err != nil {
			return fmt.Errorf("scan virtual table: %w", err)
		}

		b.WriteString(sqlStmt)
		b.WriteString(";\n\n")
	}

	return rows.Err()
}

// isFTSShadow returns true if the name looks like an FTS5 shadow table.
func isFTSShadow(name string) bool {
	suffixes := []string{
		"_content", "_data", "_docsize", "_idx", "_config",
	}
	for _, suffix := range suffixes {
		if strings.HasSuffix(name, suffix) {
			// Check if the base is a known FTS table.
			base := strings.TrimSuffix(name, suffix)
			if strings.HasSuffix(base, "_fts") {
				return true
			}
		}
	}

	return false
}
