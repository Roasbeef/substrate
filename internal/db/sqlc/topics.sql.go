// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: topics.sql

package sqlc

import (
	"context"
	"database/sql"
)

const CountSubscribersByTopic = `-- name: CountSubscribersByTopic :one
SELECT COUNT(*) FROM subscriptions WHERE topic_id = ?
`

func (q *Queries) CountSubscribersByTopic(ctx context.Context, topicID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, CountSubscribersByTopic, topicID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CreateSubscription = `-- name: CreateSubscription :exec
INSERT INTO subscriptions (agent_id, topic_id, subscribed_at)
VALUES (?, ?, ?)
ON CONFLICT (agent_id, topic_id) DO NOTHING
`

type CreateSubscriptionParams struct {
	AgentID      int64
	TopicID      int64
	SubscribedAt int64
}

func (q *Queries) CreateSubscription(ctx context.Context, arg CreateSubscriptionParams) error {
	_, err := q.db.ExecContext(ctx, CreateSubscription, arg.AgentID, arg.TopicID, arg.SubscribedAt)
	return err
}

const CreateTopic = `-- name: CreateTopic :one
INSERT INTO topics (name, topic_type, retention_seconds, created_at)
VALUES (?, ?, ?, ?)
RETURNING id, name, topic_type, retention_seconds, created_at
`

type CreateTopicParams struct {
	Name             string
	TopicType        string
	RetentionSeconds sql.NullInt64
	CreatedAt        int64
}

func (q *Queries) CreateTopic(ctx context.Context, arg CreateTopicParams) (Topic, error) {
	row := q.db.QueryRowContext(ctx, CreateTopic,
		arg.Name,
		arg.TopicType,
		arg.RetentionSeconds,
		arg.CreatedAt,
	)
	var i Topic
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.TopicType,
		&i.RetentionSeconds,
		&i.CreatedAt,
	)
	return i, err
}

const DeleteSubscription = `-- name: DeleteSubscription :exec
DELETE FROM subscriptions WHERE agent_id = ? AND topic_id = ?
`

type DeleteSubscriptionParams struct {
	AgentID int64
	TopicID int64
}

func (q *Queries) DeleteSubscription(ctx context.Context, arg DeleteSubscriptionParams) error {
	_, err := q.db.ExecContext(ctx, DeleteSubscription, arg.AgentID, arg.TopicID)
	return err
}

const DeleteTopic = `-- name: DeleteTopic :exec
DELETE FROM topics WHERE id = ?
`

func (q *Queries) DeleteTopic(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, DeleteTopic, id)
	return err
}

const GetConsumerOffset = `-- name: GetConsumerOffset :one
SELECT last_offset FROM consumer_offsets
WHERE agent_id = ? AND topic_id = ?
`

type GetConsumerOffsetParams struct {
	AgentID int64
	TopicID int64
}

func (q *Queries) GetConsumerOffset(ctx context.Context, arg GetConsumerOffsetParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, GetConsumerOffset, arg.AgentID, arg.TopicID)
	var last_offset int64
	err := row.Scan(&last_offset)
	return last_offset, err
}

const GetOrCreateAgentInboxTopic = `-- name: GetOrCreateAgentInboxTopic :one
INSERT INTO topics (name, topic_type, retention_seconds, created_at)
VALUES ('agent/' || ? || '/inbox', 'direct', 604800, ?)
ON CONFLICT (name) DO UPDATE SET name = topics.name
RETURNING id, name, topic_type, retention_seconds, created_at
`

type GetOrCreateAgentInboxTopicParams struct {
	Column1   sql.NullString
	CreatedAt int64
}

func (q *Queries) GetOrCreateAgentInboxTopic(ctx context.Context, arg GetOrCreateAgentInboxTopicParams) (Topic, error) {
	row := q.db.QueryRowContext(ctx, GetOrCreateAgentInboxTopic, arg.Column1, arg.CreatedAt)
	var i Topic
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.TopicType,
		&i.RetentionSeconds,
		&i.CreatedAt,
	)
	return i, err
}

const GetOrCreateTopic = `-- name: GetOrCreateTopic :one
INSERT INTO topics (name, topic_type, retention_seconds, created_at)
VALUES (?, ?, 604800, ?)
ON CONFLICT (name) DO UPDATE SET name = topics.name
RETURNING id, name, topic_type, retention_seconds, created_at
`

type GetOrCreateTopicParams struct {
	Name      string
	TopicType string
	CreatedAt int64
}

func (q *Queries) GetOrCreateTopic(ctx context.Context, arg GetOrCreateTopicParams) (Topic, error) {
	row := q.db.QueryRowContext(ctx, GetOrCreateTopic, arg.Name, arg.TopicType, arg.CreatedAt)
	var i Topic
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.TopicType,
		&i.RetentionSeconds,
		&i.CreatedAt,
	)
	return i, err
}

const GetSubscription = `-- name: GetSubscription :one
SELECT id, agent_id, topic_id, subscribed_at FROM subscriptions WHERE agent_id = ? AND topic_id = ?
`

type GetSubscriptionParams struct {
	AgentID int64
	TopicID int64
}

func (q *Queries) GetSubscription(ctx context.Context, arg GetSubscriptionParams) (Subscription, error) {
	row := q.db.QueryRowContext(ctx, GetSubscription, arg.AgentID, arg.TopicID)
	var i Subscription
	err := row.Scan(
		&i.ID,
		&i.AgentID,
		&i.TopicID,
		&i.SubscribedAt,
	)
	return i, err
}

const GetTopic = `-- name: GetTopic :one
SELECT id, name, topic_type, retention_seconds, created_at FROM topics WHERE id = ?
`

func (q *Queries) GetTopic(ctx context.Context, id int64) (Topic, error) {
	row := q.db.QueryRowContext(ctx, GetTopic, id)
	var i Topic
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.TopicType,
		&i.RetentionSeconds,
		&i.CreatedAt,
	)
	return i, err
}

const GetTopicByName = `-- name: GetTopicByName :one
SELECT id, name, topic_type, retention_seconds, created_at FROM topics WHERE name = ?
`

func (q *Queries) GetTopicByName(ctx context.Context, name string) (Topic, error) {
	row := q.db.QueryRowContext(ctx, GetTopicByName, name)
	var i Topic
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.TopicType,
		&i.RetentionSeconds,
		&i.CreatedAt,
	)
	return i, err
}

const ListConsumerOffsetsByAgent = `-- name: ListConsumerOffsetsByAgent :many
SELECT co.topic_id, co.last_offset, t.name as topic_name
FROM consumer_offsets co
JOIN topics t ON co.topic_id = t.id
WHERE co.agent_id = ?
`

type ListConsumerOffsetsByAgentRow struct {
	TopicID    int64
	LastOffset int64
	TopicName  string
}

func (q *Queries) ListConsumerOffsetsByAgent(ctx context.Context, agentID int64) ([]ListConsumerOffsetsByAgentRow, error) {
	rows, err := q.db.QueryContext(ctx, ListConsumerOffsetsByAgent, agentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListConsumerOffsetsByAgentRow
	for rows.Next() {
		var i ListConsumerOffsetsByAgentRow
		if err := rows.Scan(&i.TopicID, &i.LastOffset, &i.TopicName); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListSubscriptionsByAgent = `-- name: ListSubscriptionsByAgent :many
SELECT t.id, t.name, t.topic_type, t.retention_seconds, t.created_at FROM topics t
JOIN subscriptions s ON t.id = s.topic_id
WHERE s.agent_id = ?
ORDER BY t.name
`

func (q *Queries) ListSubscriptionsByAgent(ctx context.Context, agentID int64) ([]Topic, error) {
	rows, err := q.db.QueryContext(ctx, ListSubscriptionsByAgent, agentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Topic
	for rows.Next() {
		var i Topic
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.TopicType,
			&i.RetentionSeconds,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListSubscriptionsByTopic = `-- name: ListSubscriptionsByTopic :many
SELECT a.id, a.name, a.project_key, a.current_session_id, a.created_at, a.last_active_at FROM agents a
JOIN subscriptions s ON a.id = s.agent_id
WHERE s.topic_id = ?
ORDER BY a.name
`

func (q *Queries) ListSubscriptionsByTopic(ctx context.Context, topicID int64) ([]Agent, error) {
	rows, err := q.db.QueryContext(ctx, ListSubscriptionsByTopic, topicID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Agent
	for rows.Next() {
		var i Agent
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ProjectKey,
			&i.CurrentSessionID,
			&i.CreatedAt,
			&i.LastActiveAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListTopics = `-- name: ListTopics :many
SELECT id, name, topic_type, retention_seconds, created_at FROM topics ORDER BY name
`

func (q *Queries) ListTopics(ctx context.Context) ([]Topic, error) {
	rows, err := q.db.QueryContext(ctx, ListTopics)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Topic
	for rows.Next() {
		var i Topic
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.TopicType,
			&i.RetentionSeconds,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListTopicsByType = `-- name: ListTopicsByType :many
SELECT id, name, topic_type, retention_seconds, created_at FROM topics WHERE topic_type = ? ORDER BY name
`

func (q *Queries) ListTopicsByType(ctx context.Context, topicType string) ([]Topic, error) {
	rows, err := q.db.QueryContext(ctx, ListTopicsByType, topicType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Topic
	for rows.Next() {
		var i Topic
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.TopicType,
			&i.RetentionSeconds,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateTopicRetention = `-- name: UpdateTopicRetention :exec
UPDATE topics SET retention_seconds = ? WHERE id = ?
`

type UpdateTopicRetentionParams struct {
	RetentionSeconds sql.NullInt64
	ID               int64
}

func (q *Queries) UpdateTopicRetention(ctx context.Context, arg UpdateTopicRetentionParams) error {
	_, err := q.db.ExecContext(ctx, UpdateTopicRetention, arg.RetentionSeconds, arg.ID)
	return err
}

const UpsertConsumerOffset = `-- name: UpsertConsumerOffset :exec
INSERT INTO consumer_offsets (agent_id, topic_id, last_offset, updated_at)
VALUES (?, ?, ?, ?)
ON CONFLICT (agent_id, topic_id) DO UPDATE SET
    last_offset = excluded.last_offset,
    updated_at = excluded.updated_at
`

type UpsertConsumerOffsetParams struct {
	AgentID    int64
	TopicID    int64
	LastOffset int64
	UpdatedAt  int64
}

func (q *Queries) UpsertConsumerOffset(ctx context.Context, arg UpsertConsumerOffsetParams) error {
	_, err := q.db.ExecContext(ctx, UpsertConsumerOffset,
		arg.AgentID,
		arg.TopicID,
		arg.LastOffset,
		arg.UpdatedAt,
	)
	return err
}
