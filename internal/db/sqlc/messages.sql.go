// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: messages.sql

package sqlc

import (
	"context"
	"database/sql"
)

const CountArchivedByAgent = `-- name: CountArchivedByAgent :one
SELECT COUNT(*) FROM message_recipients
WHERE agent_id = ? AND state = 'archived'
`

func (q *Queries) CountArchivedByAgent(ctx context.Context, agentID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, CountArchivedByAgent, agentID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CountSentByAgent = `-- name: CountSentByAgent :one
SELECT COUNT(*) FROM messages
WHERE sender_id = ?
`

func (q *Queries) CountSentByAgent(ctx context.Context, senderID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, CountSentByAgent, senderID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CountSnoozedByAgent = `-- name: CountSnoozedByAgent :one
SELECT COUNT(*) FROM message_recipients
WHERE agent_id = ? AND state = 'snoozed'
`

func (q *Queries) CountSnoozedByAgent(ctx context.Context, agentID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, CountSnoozedByAgent, agentID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CountStarredByAgent = `-- name: CountStarredByAgent :one
SELECT COUNT(*) FROM message_recipients
WHERE agent_id = ? AND state = 'starred'
`

func (q *Queries) CountStarredByAgent(ctx context.Context, agentID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, CountStarredByAgent, agentID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CountUnreadByAgent = `-- name: CountUnreadByAgent :one
SELECT COUNT(*) FROM message_recipients
WHERE agent_id = ? AND state = 'unread'
`

func (q *Queries) CountUnreadByAgent(ctx context.Context, agentID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, CountUnreadByAgent, agentID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CountUnreadUrgentByAgent = `-- name: CountUnreadUrgentByAgent :one
SELECT COUNT(*) FROM message_recipients mr
JOIN messages m ON mr.message_id = m.id
WHERE mr.agent_id = ? AND mr.state = 'unread' AND m.priority = 'urgent'
`

func (q *Queries) CountUnreadUrgentByAgent(ctx context.Context, agentID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, CountUnreadUrgentByAgent, agentID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CreateMessage = `-- name: CreateMessage :one
INSERT INTO messages (
    thread_id, topic_id, log_offset, sender_id, subject, body_md,
    priority, deadline_at, attachments, created_at
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, thread_id, topic_id, log_offset, sender_id, subject, body_md, priority, deadline_at, attachments, created_at
`

type CreateMessageParams struct {
	ThreadID    string
	TopicID     int64
	LogOffset   int64
	SenderID    int64
	Subject     string
	BodyMd      string
	Priority    string
	DeadlineAt  sql.NullInt64
	Attachments sql.NullString
	CreatedAt   int64
}

func (q *Queries) CreateMessage(ctx context.Context, arg CreateMessageParams) (Message, error) {
	row := q.db.QueryRowContext(ctx, CreateMessage,
		arg.ThreadID,
		arg.TopicID,
		arg.LogOffset,
		arg.SenderID,
		arg.Subject,
		arg.BodyMd,
		arg.Priority,
		arg.DeadlineAt,
		arg.Attachments,
		arg.CreatedAt,
	)
	var i Message
	err := row.Scan(
		&i.ID,
		&i.ThreadID,
		&i.TopicID,
		&i.LogOffset,
		&i.SenderID,
		&i.Subject,
		&i.BodyMd,
		&i.Priority,
		&i.DeadlineAt,
		&i.Attachments,
		&i.CreatedAt,
	)
	return i, err
}

const CreateMessageRecipient = `-- name: CreateMessageRecipient :exec
INSERT INTO message_recipients (message_id, agent_id, state)
VALUES (?, ?, 'unread')
`

type CreateMessageRecipientParams struct {
	MessageID int64
	AgentID   int64
}

func (q *Queries) CreateMessageRecipient(ctx context.Context, arg CreateMessageRecipientParams) error {
	_, err := q.db.ExecContext(ctx, CreateMessageRecipient, arg.MessageID, arg.AgentID)
	return err
}

const DeleteMessage = `-- name: DeleteMessage :exec
DELETE FROM messages WHERE id = ?
`

func (q *Queries) DeleteMessage(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, DeleteMessage, id)
	return err
}

const DeleteMessagesByTopicOlderThan = `-- name: DeleteMessagesByTopicOlderThan :execrows
DELETE FROM messages WHERE topic_id = ? AND created_at < ?
`

type DeleteMessagesByTopicOlderThanParams struct {
	TopicID   int64
	CreatedAt int64
}

func (q *Queries) DeleteMessagesByTopicOlderThan(ctx context.Context, arg DeleteMessagesByTopicOlderThanParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, DeleteMessagesByTopicOlderThan, arg.TopicID, arg.CreatedAt)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const GetArchivedMessages = `-- name: GetArchivedMessages :many
SELECT m.id, m.thread_id, m.topic_id, m.log_offset, m.sender_id, m.subject, m.body_md, m.priority, m.deadline_at, m.attachments, m.created_at, mr.state, mr.snoozed_until, mr.read_at, mr.acked_at
FROM messages m
JOIN message_recipients mr ON m.id = mr.message_id
WHERE mr.agent_id = ?
    AND mr.state = 'archived'
ORDER BY m.created_at DESC
LIMIT ?
`

type GetArchivedMessagesParams struct {
	AgentID int64
	Limit   int64
}

type GetArchivedMessagesRow struct {
	ID           int64
	ThreadID     string
	TopicID      int64
	LogOffset    int64
	SenderID     int64
	Subject      string
	BodyMd       string
	Priority     string
	DeadlineAt   sql.NullInt64
	Attachments  sql.NullString
	CreatedAt    int64
	State        string
	SnoozedUntil sql.NullInt64
	ReadAt       sql.NullInt64
	AckedAt      sql.NullInt64
}

func (q *Queries) GetArchivedMessages(ctx context.Context, arg GetArchivedMessagesParams) ([]GetArchivedMessagesRow, error) {
	rows, err := q.db.QueryContext(ctx, GetArchivedMessages, arg.AgentID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetArchivedMessagesRow
	for rows.Next() {
		var i GetArchivedMessagesRow
		if err := rows.Scan(
			&i.ID,
			&i.ThreadID,
			&i.TopicID,
			&i.LogOffset,
			&i.SenderID,
			&i.Subject,
			&i.BodyMd,
			&i.Priority,
			&i.DeadlineAt,
			&i.Attachments,
			&i.CreatedAt,
			&i.State,
			&i.SnoozedUntil,
			&i.ReadAt,
			&i.AckedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetInboxMessages = `-- name: GetInboxMessages :many
SELECT m.id, m.thread_id, m.topic_id, m.log_offset, m.sender_id, m.subject, m.body_md, m.priority, m.deadline_at, m.attachments, m.created_at, mr.state, mr.snoozed_until, mr.read_at, mr.acked_at
FROM messages m
JOIN message_recipients mr ON m.id = mr.message_id
WHERE mr.agent_id = ?
    AND mr.state NOT IN ('archived', 'trash')
ORDER BY m.created_at DESC
LIMIT ?
`

type GetInboxMessagesParams struct {
	AgentID int64
	Limit   int64
}

type GetInboxMessagesRow struct {
	ID           int64
	ThreadID     string
	TopicID      int64
	LogOffset    int64
	SenderID     int64
	Subject      string
	BodyMd       string
	Priority     string
	DeadlineAt   sql.NullInt64
	Attachments  sql.NullString
	CreatedAt    int64
	State        string
	SnoozedUntil sql.NullInt64
	ReadAt       sql.NullInt64
	AckedAt      sql.NullInt64
}

func (q *Queries) GetInboxMessages(ctx context.Context, arg GetInboxMessagesParams) ([]GetInboxMessagesRow, error) {
	rows, err := q.db.QueryContext(ctx, GetInboxMessages, arg.AgentID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetInboxMessagesRow
	for rows.Next() {
		var i GetInboxMessagesRow
		if err := rows.Scan(
			&i.ID,
			&i.ThreadID,
			&i.TopicID,
			&i.LogOffset,
			&i.SenderID,
			&i.Subject,
			&i.BodyMd,
			&i.Priority,
			&i.DeadlineAt,
			&i.Attachments,
			&i.CreatedAt,
			&i.State,
			&i.SnoozedUntil,
			&i.ReadAt,
			&i.AckedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetMaxLogOffset = `-- name: GetMaxLogOffset :one
SELECT COALESCE(MAX(log_offset), 0) FROM messages WHERE topic_id = ?
`

func (q *Queries) GetMaxLogOffset(ctx context.Context, topicID int64) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, GetMaxLogOffset, topicID)
	var coalesce interface{}
	err := row.Scan(&coalesce)
	return coalesce, err
}

const GetMessage = `-- name: GetMessage :one
SELECT id, thread_id, topic_id, log_offset, sender_id, subject, body_md, priority, deadline_at, attachments, created_at FROM messages WHERE id = ?
`

func (q *Queries) GetMessage(ctx context.Context, id int64) (Message, error) {
	row := q.db.QueryRowContext(ctx, GetMessage, id)
	var i Message
	err := row.Scan(
		&i.ID,
		&i.ThreadID,
		&i.TopicID,
		&i.LogOffset,
		&i.SenderID,
		&i.Subject,
		&i.BodyMd,
		&i.Priority,
		&i.DeadlineAt,
		&i.Attachments,
		&i.CreatedAt,
	)
	return i, err
}

const GetMessageRecipient = `-- name: GetMessageRecipient :one
SELECT message_id, agent_id, state, snoozed_until, read_at, acked_at FROM message_recipients
WHERE message_id = ? AND agent_id = ?
`

type GetMessageRecipientParams struct {
	MessageID int64
	AgentID   int64
}

func (q *Queries) GetMessageRecipient(ctx context.Context, arg GetMessageRecipientParams) (MessageRecipient, error) {
	row := q.db.QueryRowContext(ctx, GetMessageRecipient, arg.MessageID, arg.AgentID)
	var i MessageRecipient
	err := row.Scan(
		&i.MessageID,
		&i.AgentID,
		&i.State,
		&i.SnoozedUntil,
		&i.ReadAt,
		&i.AckedAt,
	)
	return i, err
}

const GetMessagesByThread = `-- name: GetMessagesByThread :many
SELECT id, thread_id, topic_id, log_offset, sender_id, subject, body_md, priority, deadline_at, attachments, created_at FROM messages WHERE thread_id = ? ORDER BY created_at ASC
`

func (q *Queries) GetMessagesByThread(ctx context.Context, threadID string) ([]Message, error) {
	rows, err := q.db.QueryContext(ctx, GetMessagesByThread, threadID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Message
	for rows.Next() {
		var i Message
		if err := rows.Scan(
			&i.ID,
			&i.ThreadID,
			&i.TopicID,
			&i.LogOffset,
			&i.SenderID,
			&i.Subject,
			&i.BodyMd,
			&i.Priority,
			&i.DeadlineAt,
			&i.Attachments,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetMessagesByTopic = `-- name: GetMessagesByTopic :many
SELECT id, thread_id, topic_id, log_offset, sender_id, subject, body_md, priority, deadline_at, attachments, created_at FROM messages WHERE topic_id = ? ORDER BY log_offset ASC
`

func (q *Queries) GetMessagesByTopic(ctx context.Context, topicID int64) ([]Message, error) {
	rows, err := q.db.QueryContext(ctx, GetMessagesByTopic, topicID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Message
	for rows.Next() {
		var i Message
		if err := rows.Scan(
			&i.ID,
			&i.ThreadID,
			&i.TopicID,
			&i.LogOffset,
			&i.SenderID,
			&i.Subject,
			&i.BodyMd,
			&i.Priority,
			&i.DeadlineAt,
			&i.Attachments,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetMessagesSinceOffset = `-- name: GetMessagesSinceOffset :many
SELECT id, thread_id, topic_id, log_offset, sender_id, subject, body_md, priority, deadline_at, attachments, created_at FROM messages
WHERE topic_id = ? AND log_offset > ?
ORDER BY log_offset ASC
LIMIT ?
`

type GetMessagesSinceOffsetParams struct {
	TopicID   int64
	LogOffset int64
	Limit     int64
}

func (q *Queries) GetMessagesSinceOffset(ctx context.Context, arg GetMessagesSinceOffsetParams) ([]Message, error) {
	rows, err := q.db.QueryContext(ctx, GetMessagesSinceOffset, arg.TopicID, arg.LogOffset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Message
	for rows.Next() {
		var i Message
		if err := rows.Scan(
			&i.ID,
			&i.ThreadID,
			&i.TopicID,
			&i.LogOffset,
			&i.SenderID,
			&i.Subject,
			&i.BodyMd,
			&i.Priority,
			&i.DeadlineAt,
			&i.Attachments,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetSentMessages = `-- name: GetSentMessages :many
SELECT id, thread_id, topic_id, log_offset, sender_id, subject, body_md, priority, deadline_at, attachments, created_at FROM messages
WHERE sender_id = ?
ORDER BY created_at DESC
LIMIT ?
`

type GetSentMessagesParams struct {
	SenderID int64
	Limit    int64
}

func (q *Queries) GetSentMessages(ctx context.Context, arg GetSentMessagesParams) ([]Message, error) {
	rows, err := q.db.QueryContext(ctx, GetSentMessages, arg.SenderID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Message
	for rows.Next() {
		var i Message
		if err := rows.Scan(
			&i.ID,
			&i.ThreadID,
			&i.TopicID,
			&i.LogOffset,
			&i.SenderID,
			&i.Subject,
			&i.BodyMd,
			&i.Priority,
			&i.DeadlineAt,
			&i.Attachments,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetSnoozedMessages = `-- name: GetSnoozedMessages :many
SELECT m.id, m.thread_id, m.topic_id, m.log_offset, m.sender_id, m.subject, m.body_md, m.priority, m.deadline_at, m.attachments, m.created_at, mr.state, mr.snoozed_until, mr.read_at, mr.acked_at
FROM messages m
JOIN message_recipients mr ON m.id = mr.message_id
WHERE mr.agent_id = ?
    AND mr.state = 'snoozed'
ORDER BY mr.snoozed_until ASC
LIMIT ?
`

type GetSnoozedMessagesParams struct {
	AgentID int64
	Limit   int64
}

type GetSnoozedMessagesRow struct {
	ID           int64
	ThreadID     string
	TopicID      int64
	LogOffset    int64
	SenderID     int64
	Subject      string
	BodyMd       string
	Priority     string
	DeadlineAt   sql.NullInt64
	Attachments  sql.NullString
	CreatedAt    int64
	State        string
	SnoozedUntil sql.NullInt64
	ReadAt       sql.NullInt64
	AckedAt      sql.NullInt64
}

func (q *Queries) GetSnoozedMessages(ctx context.Context, arg GetSnoozedMessagesParams) ([]GetSnoozedMessagesRow, error) {
	rows, err := q.db.QueryContext(ctx, GetSnoozedMessages, arg.AgentID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSnoozedMessagesRow
	for rows.Next() {
		var i GetSnoozedMessagesRow
		if err := rows.Scan(
			&i.ID,
			&i.ThreadID,
			&i.TopicID,
			&i.LogOffset,
			&i.SenderID,
			&i.Subject,
			&i.BodyMd,
			&i.Priority,
			&i.DeadlineAt,
			&i.Attachments,
			&i.CreatedAt,
			&i.State,
			&i.SnoozedUntil,
			&i.ReadAt,
			&i.AckedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetSnoozedMessagesReadyToWake = `-- name: GetSnoozedMessagesReadyToWake :many
SELECT m.id, m.thread_id, m.topic_id, m.log_offset, m.sender_id, m.subject, m.body_md, m.priority, m.deadline_at, m.attachments, m.created_at, mr.agent_id as recipient_agent_id
FROM messages m
JOIN message_recipients mr ON m.id = mr.message_id
WHERE mr.state = 'snoozed'
    AND mr.snoozed_until <= ?
ORDER BY mr.snoozed_until ASC
`

type GetSnoozedMessagesReadyToWakeRow struct {
	ID               int64
	ThreadID         string
	TopicID          int64
	LogOffset        int64
	SenderID         int64
	Subject          string
	BodyMd           string
	Priority         string
	DeadlineAt       sql.NullInt64
	Attachments      sql.NullString
	CreatedAt        int64
	RecipientAgentID int64
}

func (q *Queries) GetSnoozedMessagesReadyToWake(ctx context.Context, snoozedUntil sql.NullInt64) ([]GetSnoozedMessagesReadyToWakeRow, error) {
	rows, err := q.db.QueryContext(ctx, GetSnoozedMessagesReadyToWake, snoozedUntil)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSnoozedMessagesReadyToWakeRow
	for rows.Next() {
		var i GetSnoozedMessagesReadyToWakeRow
		if err := rows.Scan(
			&i.ID,
			&i.ThreadID,
			&i.TopicID,
			&i.LogOffset,
			&i.SenderID,
			&i.Subject,
			&i.BodyMd,
			&i.Priority,
			&i.DeadlineAt,
			&i.Attachments,
			&i.CreatedAt,
			&i.RecipientAgentID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetStarredMessages = `-- name: GetStarredMessages :many
SELECT m.id, m.thread_id, m.topic_id, m.log_offset, m.sender_id, m.subject, m.body_md, m.priority, m.deadline_at, m.attachments, m.created_at, mr.state, mr.snoozed_until, mr.read_at, mr.acked_at
FROM messages m
JOIN message_recipients mr ON m.id = mr.message_id
WHERE mr.agent_id = ?
    AND mr.state = 'starred'
ORDER BY m.created_at DESC
LIMIT ?
`

type GetStarredMessagesParams struct {
	AgentID int64
	Limit   int64
}

type GetStarredMessagesRow struct {
	ID           int64
	ThreadID     string
	TopicID      int64
	LogOffset    int64
	SenderID     int64
	Subject      string
	BodyMd       string
	Priority     string
	DeadlineAt   sql.NullInt64
	Attachments  sql.NullString
	CreatedAt    int64
	State        string
	SnoozedUntil sql.NullInt64
	ReadAt       sql.NullInt64
	AckedAt      sql.NullInt64
}

func (q *Queries) GetStarredMessages(ctx context.Context, arg GetStarredMessagesParams) ([]GetStarredMessagesRow, error) {
	rows, err := q.db.QueryContext(ctx, GetStarredMessages, arg.AgentID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetStarredMessagesRow
	for rows.Next() {
		var i GetStarredMessagesRow
		if err := rows.Scan(
			&i.ID,
			&i.ThreadID,
			&i.TopicID,
			&i.LogOffset,
			&i.SenderID,
			&i.Subject,
			&i.BodyMd,
			&i.Priority,
			&i.DeadlineAt,
			&i.Attachments,
			&i.CreatedAt,
			&i.State,
			&i.SnoozedUntil,
			&i.ReadAt,
			&i.AckedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetTrashMessages = `-- name: GetTrashMessages :many
SELECT m.id, m.thread_id, m.topic_id, m.log_offset, m.sender_id, m.subject, m.body_md, m.priority, m.deadline_at, m.attachments, m.created_at, mr.state, mr.snoozed_until, mr.read_at, mr.acked_at
FROM messages m
JOIN message_recipients mr ON m.id = mr.message_id
WHERE mr.agent_id = ?
    AND mr.state = 'trash'
ORDER BY m.created_at DESC
LIMIT ?
`

type GetTrashMessagesParams struct {
	AgentID int64
	Limit   int64
}

type GetTrashMessagesRow struct {
	ID           int64
	ThreadID     string
	TopicID      int64
	LogOffset    int64
	SenderID     int64
	Subject      string
	BodyMd       string
	Priority     string
	DeadlineAt   sql.NullInt64
	Attachments  sql.NullString
	CreatedAt    int64
	State        string
	SnoozedUntil sql.NullInt64
	ReadAt       sql.NullInt64
	AckedAt      sql.NullInt64
}

func (q *Queries) GetTrashMessages(ctx context.Context, arg GetTrashMessagesParams) ([]GetTrashMessagesRow, error) {
	rows, err := q.db.QueryContext(ctx, GetTrashMessages, arg.AgentID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTrashMessagesRow
	for rows.Next() {
		var i GetTrashMessagesRow
		if err := rows.Scan(
			&i.ID,
			&i.ThreadID,
			&i.TopicID,
			&i.LogOffset,
			&i.SenderID,
			&i.Subject,
			&i.BodyMd,
			&i.Priority,
			&i.DeadlineAt,
			&i.Attachments,
			&i.CreatedAt,
			&i.State,
			&i.SnoozedUntil,
			&i.ReadAt,
			&i.AckedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetUnreadMessages = `-- name: GetUnreadMessages :many
SELECT m.id, m.thread_id, m.topic_id, m.log_offset, m.sender_id, m.subject, m.body_md, m.priority, m.deadline_at, m.attachments, m.created_at, mr.state, mr.snoozed_until, mr.read_at, mr.acked_at
FROM messages m
JOIN message_recipients mr ON m.id = mr.message_id
WHERE mr.agent_id = ?
    AND mr.state = 'unread'
ORDER BY m.created_at DESC
LIMIT ?
`

type GetUnreadMessagesParams struct {
	AgentID int64
	Limit   int64
}

type GetUnreadMessagesRow struct {
	ID           int64
	ThreadID     string
	TopicID      int64
	LogOffset    int64
	SenderID     int64
	Subject      string
	BodyMd       string
	Priority     string
	DeadlineAt   sql.NullInt64
	Attachments  sql.NullString
	CreatedAt    int64
	State        string
	SnoozedUntil sql.NullInt64
	ReadAt       sql.NullInt64
	AckedAt      sql.NullInt64
}

func (q *Queries) GetUnreadMessages(ctx context.Context, arg GetUnreadMessagesParams) ([]GetUnreadMessagesRow, error) {
	rows, err := q.db.QueryContext(ctx, GetUnreadMessages, arg.AgentID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUnreadMessagesRow
	for rows.Next() {
		var i GetUnreadMessagesRow
		if err := rows.Scan(
			&i.ID,
			&i.ThreadID,
			&i.TopicID,
			&i.LogOffset,
			&i.SenderID,
			&i.Subject,
			&i.BodyMd,
			&i.Priority,
			&i.DeadlineAt,
			&i.Attachments,
			&i.CreatedAt,
			&i.State,
			&i.SnoozedUntil,
			&i.ReadAt,
			&i.AckedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListMessagesByPriority = `-- name: ListMessagesByPriority :many
SELECT m.id, m.thread_id, m.topic_id, m.log_offset, m.sender_id, m.subject, m.body_md, m.priority, m.deadline_at, m.attachments, m.created_at FROM messages m
JOIN message_recipients mr ON m.id = mr.message_id
WHERE mr.agent_id = ? AND m.priority = ?
ORDER BY m.created_at DESC
LIMIT ?
`

type ListMessagesByPriorityParams struct {
	AgentID  int64
	Priority string
	Limit    int64
}

func (q *Queries) ListMessagesByPriority(ctx context.Context, arg ListMessagesByPriorityParams) ([]Message, error) {
	rows, err := q.db.QueryContext(ctx, ListMessagesByPriority, arg.AgentID, arg.Priority, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Message
	for rows.Next() {
		var i Message
		if err := rows.Scan(
			&i.ID,
			&i.ThreadID,
			&i.TopicID,
			&i.LogOffset,
			&i.SenderID,
			&i.Subject,
			&i.BodyMd,
			&i.Priority,
			&i.DeadlineAt,
			&i.Attachments,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateRecipientAcked = `-- name: UpdateRecipientAcked :exec
UPDATE message_recipients
SET acked_at = ?
WHERE message_id = ? AND agent_id = ?
`

type UpdateRecipientAckedParams struct {
	AckedAt   sql.NullInt64
	MessageID int64
	AgentID   int64
}

func (q *Queries) UpdateRecipientAcked(ctx context.Context, arg UpdateRecipientAckedParams) error {
	_, err := q.db.ExecContext(ctx, UpdateRecipientAcked, arg.AckedAt, arg.MessageID, arg.AgentID)
	return err
}

const UpdateRecipientSnoozed = `-- name: UpdateRecipientSnoozed :exec
UPDATE message_recipients
SET state = 'snoozed', snoozed_until = ?
WHERE message_id = ? AND agent_id = ?
`

type UpdateRecipientSnoozedParams struct {
	SnoozedUntil sql.NullInt64
	MessageID    int64
	AgentID      int64
}

func (q *Queries) UpdateRecipientSnoozed(ctx context.Context, arg UpdateRecipientSnoozedParams) error {
	_, err := q.db.ExecContext(ctx, UpdateRecipientSnoozed, arg.SnoozedUntil, arg.MessageID, arg.AgentID)
	return err
}

const UpdateRecipientState = `-- name: UpdateRecipientState :exec
UPDATE message_recipients
SET state = ?, read_at = CASE WHEN ? = 'read' THEN ? ELSE read_at END
WHERE message_id = ? AND agent_id = ?
`

type UpdateRecipientStateParams struct {
	State     string
	Column2   interface{}
	ReadAt    sql.NullInt64
	MessageID int64
	AgentID   int64
}

func (q *Queries) UpdateRecipientState(ctx context.Context, arg UpdateRecipientStateParams) error {
	_, err := q.db.ExecContext(ctx, UpdateRecipientState,
		arg.State,
		arg.Column2,
		arg.ReadAt,
		arg.MessageID,
		arg.AgentID,
	)
	return err
}

const WakeSnoozedMessages = `-- name: WakeSnoozedMessages :execrows
UPDATE message_recipients
SET state = 'unread', snoozed_until = NULL
WHERE state = 'snoozed' AND snoozed_until <= ?
`

func (q *Queries) WakeSnoozedMessages(ctx context.Context, snoozedUntil sql.NullInt64) (int64, error) {
	result, err := q.db.ExecContext(ctx, WakeSnoozedMessages, snoozedUntil)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}
