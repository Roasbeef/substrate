// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: messages.sql

package sqlc

import (
	"context"
	"database/sql"
)

const CountArchivedByAgent = `-- name: CountArchivedByAgent :one
SELECT COUNT(*) FROM message_recipients
WHERE agent_id = ? AND state = 'archived'
`

func (q *Queries) CountArchivedByAgent(ctx context.Context, agentID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, CountArchivedByAgent, agentID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CountSentByAgent = `-- name: CountSentByAgent :one
SELECT COUNT(*) FROM messages
WHERE sender_id = ? AND deleted_by_sender = 0
`

func (q *Queries) CountSentByAgent(ctx context.Context, senderID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, CountSentByAgent, senderID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CountSnoozedByAgent = `-- name: CountSnoozedByAgent :one
SELECT COUNT(*) FROM message_recipients
WHERE agent_id = ? AND state = 'snoozed'
`

func (q *Queries) CountSnoozedByAgent(ctx context.Context, agentID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, CountSnoozedByAgent, agentID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CountStarredByAgent = `-- name: CountStarredByAgent :one
SELECT COUNT(*) FROM message_recipients
WHERE agent_id = ? AND state = 'starred'
`

func (q *Queries) CountStarredByAgent(ctx context.Context, agentID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, CountStarredByAgent, agentID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CountUnreadByAgent = `-- name: CountUnreadByAgent :one
SELECT COUNT(*) FROM message_recipients
WHERE agent_id = ? AND state = 'unread'
`

func (q *Queries) CountUnreadByAgent(ctx context.Context, agentID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, CountUnreadByAgent, agentID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CountUnreadUrgentByAgent = `-- name: CountUnreadUrgentByAgent :one
SELECT COUNT(*) FROM message_recipients mr
JOIN messages m ON mr.message_id = m.id
WHERE mr.agent_id = ? AND mr.state = 'unread' AND m.priority = 'urgent'
`

func (q *Queries) CountUnreadUrgentByAgent(ctx context.Context, agentID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, CountUnreadUrgentByAgent, agentID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CreateMessage = `-- name: CreateMessage :one
INSERT INTO messages (
    thread_id, topic_id, log_offset, sender_id, subject, body_md,
    priority, deadline_at, attachments, created_at
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, thread_id, topic_id, log_offset, sender_id, subject, body_md, priority, deadline_at, attachments, created_at, deleted_by_sender
`

type CreateMessageParams struct {
	ThreadID    string
	TopicID     int64
	LogOffset   int64
	SenderID    int64
	Subject     string
	BodyMd      string
	Priority    string
	DeadlineAt  sql.NullInt64
	Attachments sql.NullString
	CreatedAt   int64
}

func (q *Queries) CreateMessage(ctx context.Context, arg CreateMessageParams) (Message, error) {
	row := q.db.QueryRowContext(ctx, CreateMessage,
		arg.ThreadID,
		arg.TopicID,
		arg.LogOffset,
		arg.SenderID,
		arg.Subject,
		arg.BodyMd,
		arg.Priority,
		arg.DeadlineAt,
		arg.Attachments,
		arg.CreatedAt,
	)
	var i Message
	err := row.Scan(
		&i.ID,
		&i.ThreadID,
		&i.TopicID,
		&i.LogOffset,
		&i.SenderID,
		&i.Subject,
		&i.BodyMd,
		&i.Priority,
		&i.DeadlineAt,
		&i.Attachments,
		&i.CreatedAt,
		&i.DeletedBySender,
	)
	return i, err
}

const CreateMessageRecipient = `-- name: CreateMessageRecipient :exec
INSERT INTO message_recipients (message_id, agent_id, state)
VALUES (?, ?, 'unread')
`

type CreateMessageRecipientParams struct {
	MessageID int64
	AgentID   int64
}

func (q *Queries) CreateMessageRecipient(ctx context.Context, arg CreateMessageRecipientParams) error {
	_, err := q.db.ExecContext(ctx, CreateMessageRecipient, arg.MessageID, arg.AgentID)
	return err
}

const DeleteMessage = `-- name: DeleteMessage :exec
DELETE FROM messages WHERE id = ?
`

func (q *Queries) DeleteMessage(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, DeleteMessage, id)
	return err
}

const DeleteMessagesByTopicOlderThan = `-- name: DeleteMessagesByTopicOlderThan :execrows
DELETE FROM messages WHERE topic_id = ? AND created_at < ?
`

type DeleteMessagesByTopicOlderThanParams struct {
	TopicID   int64
	CreatedAt int64
}

func (q *Queries) DeleteMessagesByTopicOlderThan(ctx context.Context, arg DeleteMessagesByTopicOlderThanParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, DeleteMessagesByTopicOlderThan, arg.TopicID, arg.CreatedAt)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const GetAllInboxMessages = `-- name: GetAllInboxMessages :many
SELECT m.id, m.thread_id, m.topic_id, m.log_offset, m.sender_id, m.subject, m.body_md, m.priority, m.deadline_at, m.attachments, m.created_at, m.deleted_by_sender, mr.state, mr.snoozed_until, mr.read_at, mr.acked_at, mr.agent_id as recipient_agent_id
FROM messages m
JOIN message_recipients mr ON m.id = mr.message_id
WHERE mr.state NOT IN ('archived', 'trash')
ORDER BY m.created_at DESC
LIMIT ?
`

type GetAllInboxMessagesRow struct {
	ID               int64
	ThreadID         string
	TopicID          int64
	LogOffset        int64
	SenderID         int64
	Subject          string
	BodyMd           string
	Priority         string
	DeadlineAt       sql.NullInt64
	Attachments      sql.NullString
	CreatedAt        int64
	DeletedBySender  int64
	State            string
	SnoozedUntil     sql.NullInt64
	ReadAt           sql.NullInt64
	AckedAt          sql.NullInt64
	RecipientAgentID int64
}

// Global inbox view: all messages across all agents, not archived or trashed.
func (q *Queries) GetAllInboxMessages(ctx context.Context, limit int64) ([]GetAllInboxMessagesRow, error) {
	rows, err := q.db.QueryContext(ctx, GetAllInboxMessages, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllInboxMessagesRow
	for rows.Next() {
		var i GetAllInboxMessagesRow
		if err := rows.Scan(
			&i.ID,
			&i.ThreadID,
			&i.TopicID,
			&i.LogOffset,
			&i.SenderID,
			&i.Subject,
			&i.BodyMd,
			&i.Priority,
			&i.DeadlineAt,
			&i.Attachments,
			&i.CreatedAt,
			&i.DeletedBySender,
			&i.State,
			&i.SnoozedUntil,
			&i.ReadAt,
			&i.AckedAt,
			&i.RecipientAgentID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetAllSentMessages = `-- name: GetAllSentMessages :many
SELECT m.id, m.thread_id, m.topic_id, m.log_offset, m.sender_id, m.subject, m.body_md, m.priority, m.deadline_at, m.attachments, m.created_at, m.deleted_by_sender, a.name as sender_name
FROM messages m
JOIN agents a ON m.sender_id = a.id
WHERE m.deleted_by_sender = 0
ORDER BY m.created_at DESC
LIMIT ?
`

type GetAllSentMessagesRow struct {
	ID              int64
	ThreadID        string
	TopicID         int64
	LogOffset       int64
	SenderID        int64
	Subject         string
	BodyMd          string
	Priority        string
	DeadlineAt      sql.NullInt64
	Attachments     sql.NullString
	CreatedAt       int64
	DeletedBySender int64
	SenderName      string
}

// Global sent view: all sent messages across all agents.
func (q *Queries) GetAllSentMessages(ctx context.Context, limit int64) ([]GetAllSentMessagesRow, error) {
	rows, err := q.db.QueryContext(ctx, GetAllSentMessages, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllSentMessagesRow
	for rows.Next() {
		var i GetAllSentMessagesRow
		if err := rows.Scan(
			&i.ID,
			&i.ThreadID,
			&i.TopicID,
			&i.LogOffset,
			&i.SenderID,
			&i.Subject,
			&i.BodyMd,
			&i.Priority,
			&i.DeadlineAt,
			&i.Attachments,
			&i.CreatedAt,
			&i.DeletedBySender,
			&i.SenderName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetArchivedMessages = `-- name: GetArchivedMessages :many
SELECT m.id, m.thread_id, m.topic_id, m.log_offset, m.sender_id, m.subject, m.body_md, m.priority, m.deadline_at, m.attachments, m.created_at, m.deleted_by_sender, mr.state, mr.snoozed_until, mr.read_at, mr.acked_at
FROM messages m
JOIN message_recipients mr ON m.id = mr.message_id
WHERE mr.agent_id = ?
    AND mr.state = 'archived'
ORDER BY m.created_at DESC
LIMIT ?
`

type GetArchivedMessagesParams struct {
	AgentID int64
	Limit   int64
}

type GetArchivedMessagesRow struct {
	ID              int64
	ThreadID        string
	TopicID         int64
	LogOffset       int64
	SenderID        int64
	Subject         string
	BodyMd          string
	Priority        string
	DeadlineAt      sql.NullInt64
	Attachments     sql.NullString
	CreatedAt       int64
	DeletedBySender int64
	State           string
	SnoozedUntil    sql.NullInt64
	ReadAt          sql.NullInt64
	AckedAt         sql.NullInt64
}

func (q *Queries) GetArchivedMessages(ctx context.Context, arg GetArchivedMessagesParams) ([]GetArchivedMessagesRow, error) {
	rows, err := q.db.QueryContext(ctx, GetArchivedMessages, arg.AgentID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetArchivedMessagesRow
	for rows.Next() {
		var i GetArchivedMessagesRow
		if err := rows.Scan(
			&i.ID,
			&i.ThreadID,
			&i.TopicID,
			&i.LogOffset,
			&i.SenderID,
			&i.Subject,
			&i.BodyMd,
			&i.Priority,
			&i.DeadlineAt,
			&i.Attachments,
			&i.CreatedAt,
			&i.DeletedBySender,
			&i.State,
			&i.SnoozedUntil,
			&i.ReadAt,
			&i.AckedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetInboxMessages = `-- name: GetInboxMessages :many
SELECT m.id, m.thread_id, m.topic_id, m.log_offset, m.sender_id, m.subject, m.body_md, m.priority, m.deadline_at, m.attachments, m.created_at, m.deleted_by_sender, mr.state, mr.snoozed_until, mr.read_at, mr.acked_at
FROM messages m
JOIN message_recipients mr ON m.id = mr.message_id
WHERE mr.agent_id = ?
    AND mr.state NOT IN ('archived', 'trash')
ORDER BY m.created_at DESC
LIMIT ?
`

type GetInboxMessagesParams struct {
	AgentID int64
	Limit   int64
}

type GetInboxMessagesRow struct {
	ID              int64
	ThreadID        string
	TopicID         int64
	LogOffset       int64
	SenderID        int64
	Subject         string
	BodyMd          string
	Priority        string
	DeadlineAt      sql.NullInt64
	Attachments     sql.NullString
	CreatedAt       int64
	DeletedBySender int64
	State           string
	SnoozedUntil    sql.NullInt64
	ReadAt          sql.NullInt64
	AckedAt         sql.NullInt64
}

func (q *Queries) GetInboxMessages(ctx context.Context, arg GetInboxMessagesParams) ([]GetInboxMessagesRow, error) {
	rows, err := q.db.QueryContext(ctx, GetInboxMessages, arg.AgentID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetInboxMessagesRow
	for rows.Next() {
		var i GetInboxMessagesRow
		if err := rows.Scan(
			&i.ID,
			&i.ThreadID,
			&i.TopicID,
			&i.LogOffset,
			&i.SenderID,
			&i.Subject,
			&i.BodyMd,
			&i.Priority,
			&i.DeadlineAt,
			&i.Attachments,
			&i.CreatedAt,
			&i.DeletedBySender,
			&i.State,
			&i.SnoozedUntil,
			&i.ReadAt,
			&i.AckedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetMaxLogOffset = `-- name: GetMaxLogOffset :one
SELECT COALESCE(MAX(log_offset), 0) FROM messages WHERE topic_id = ?
`

func (q *Queries) GetMaxLogOffset(ctx context.Context, topicID int64) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, GetMaxLogOffset, topicID)
	var coalesce interface{}
	err := row.Scan(&coalesce)
	return coalesce, err
}

const GetMessage = `-- name: GetMessage :one
SELECT id, thread_id, topic_id, log_offset, sender_id, subject, body_md, priority, deadline_at, attachments, created_at, deleted_by_sender FROM messages WHERE id = ?
`

func (q *Queries) GetMessage(ctx context.Context, id int64) (Message, error) {
	row := q.db.QueryRowContext(ctx, GetMessage, id)
	var i Message
	err := row.Scan(
		&i.ID,
		&i.ThreadID,
		&i.TopicID,
		&i.LogOffset,
		&i.SenderID,
		&i.Subject,
		&i.BodyMd,
		&i.Priority,
		&i.DeadlineAt,
		&i.Attachments,
		&i.CreatedAt,
		&i.DeletedBySender,
	)
	return i, err
}

const GetMessageRecipient = `-- name: GetMessageRecipient :one
SELECT message_id, agent_id, state, snoozed_until, read_at, acked_at FROM message_recipients
WHERE message_id = ? AND agent_id = ?
`

type GetMessageRecipientParams struct {
	MessageID int64
	AgentID   int64
}

func (q *Queries) GetMessageRecipient(ctx context.Context, arg GetMessageRecipientParams) (MessageRecipient, error) {
	row := q.db.QueryRowContext(ctx, GetMessageRecipient, arg.MessageID, arg.AgentID)
	var i MessageRecipient
	err := row.Scan(
		&i.MessageID,
		&i.AgentID,
		&i.State,
		&i.SnoozedUntil,
		&i.ReadAt,
		&i.AckedAt,
	)
	return i, err
}

const GetMessageRecipients = `-- name: GetMessageRecipients :many
SELECT message_id, agent_id, state, snoozed_until, read_at, acked_at FROM message_recipients
WHERE message_id = ?
`

func (q *Queries) GetMessageRecipients(ctx context.Context, messageID int64) ([]MessageRecipient, error) {
	rows, err := q.db.QueryContext(ctx, GetMessageRecipients, messageID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MessageRecipient
	for rows.Next() {
		var i MessageRecipient
		if err := rows.Scan(
			&i.MessageID,
			&i.AgentID,
			&i.State,
			&i.SnoozedUntil,
			&i.ReadAt,
			&i.AckedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetMessagesByThread = `-- name: GetMessagesByThread :many
SELECT id, thread_id, topic_id, log_offset, sender_id, subject, body_md, priority, deadline_at, attachments, created_at, deleted_by_sender FROM messages WHERE thread_id = ? ORDER BY created_at ASC
`

func (q *Queries) GetMessagesByThread(ctx context.Context, threadID string) ([]Message, error) {
	rows, err := q.db.QueryContext(ctx, GetMessagesByThread, threadID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Message
	for rows.Next() {
		var i Message
		if err := rows.Scan(
			&i.ID,
			&i.ThreadID,
			&i.TopicID,
			&i.LogOffset,
			&i.SenderID,
			&i.Subject,
			&i.BodyMd,
			&i.Priority,
			&i.DeadlineAt,
			&i.Attachments,
			&i.CreatedAt,
			&i.DeletedBySender,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetMessagesByTopic = `-- name: GetMessagesByTopic :many
SELECT id, thread_id, topic_id, log_offset, sender_id, subject, body_md, priority, deadline_at, attachments, created_at, deleted_by_sender FROM messages WHERE topic_id = ? ORDER BY log_offset ASC
`

func (q *Queries) GetMessagesByTopic(ctx context.Context, topicID int64) ([]Message, error) {
	rows, err := q.db.QueryContext(ctx, GetMessagesByTopic, topicID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Message
	for rows.Next() {
		var i Message
		if err := rows.Scan(
			&i.ID,
			&i.ThreadID,
			&i.TopicID,
			&i.LogOffset,
			&i.SenderID,
			&i.Subject,
			&i.BodyMd,
			&i.Priority,
			&i.DeadlineAt,
			&i.Attachments,
			&i.CreatedAt,
			&i.DeletedBySender,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetMessagesSinceOffset = `-- name: GetMessagesSinceOffset :many
SELECT id, thread_id, topic_id, log_offset, sender_id, subject, body_md, priority, deadline_at, attachments, created_at, deleted_by_sender FROM messages
WHERE topic_id = ? AND log_offset > ?
ORDER BY log_offset ASC
LIMIT ?
`

type GetMessagesSinceOffsetParams struct {
	TopicID   int64
	LogOffset int64
	Limit     int64
}

func (q *Queries) GetMessagesSinceOffset(ctx context.Context, arg GetMessagesSinceOffsetParams) ([]Message, error) {
	rows, err := q.db.QueryContext(ctx, GetMessagesSinceOffset, arg.TopicID, arg.LogOffset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Message
	for rows.Next() {
		var i Message
		if err := rows.Scan(
			&i.ID,
			&i.ThreadID,
			&i.TopicID,
			&i.LogOffset,
			&i.SenderID,
			&i.Subject,
			&i.BodyMd,
			&i.Priority,
			&i.DeadlineAt,
			&i.Attachments,
			&i.CreatedAt,
			&i.DeletedBySender,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetSentMessages = `-- name: GetSentMessages :many
SELECT id, thread_id, topic_id, log_offset, sender_id, subject, body_md, priority, deadline_at, attachments, created_at, deleted_by_sender FROM messages
WHERE sender_id = ? AND deleted_by_sender = 0
ORDER BY created_at DESC
LIMIT ?
`

type GetSentMessagesParams struct {
	SenderID int64
	Limit    int64
}

func (q *Queries) GetSentMessages(ctx context.Context, arg GetSentMessagesParams) ([]Message, error) {
	rows, err := q.db.QueryContext(ctx, GetSentMessages, arg.SenderID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Message
	for rows.Next() {
		var i Message
		if err := rows.Scan(
			&i.ID,
			&i.ThreadID,
			&i.TopicID,
			&i.LogOffset,
			&i.SenderID,
			&i.Subject,
			&i.BodyMd,
			&i.Priority,
			&i.DeadlineAt,
			&i.Attachments,
			&i.CreatedAt,
			&i.DeletedBySender,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetSnoozedMessages = `-- name: GetSnoozedMessages :many
SELECT m.id, m.thread_id, m.topic_id, m.log_offset, m.sender_id, m.subject, m.body_md, m.priority, m.deadline_at, m.attachments, m.created_at, m.deleted_by_sender, mr.state, mr.snoozed_until, mr.read_at, mr.acked_at
FROM messages m
JOIN message_recipients mr ON m.id = mr.message_id
WHERE mr.agent_id = ?
    AND mr.state = 'snoozed'
ORDER BY mr.snoozed_until ASC
LIMIT ?
`

type GetSnoozedMessagesParams struct {
	AgentID int64
	Limit   int64
}

type GetSnoozedMessagesRow struct {
	ID              int64
	ThreadID        string
	TopicID         int64
	LogOffset       int64
	SenderID        int64
	Subject         string
	BodyMd          string
	Priority        string
	DeadlineAt      sql.NullInt64
	Attachments     sql.NullString
	CreatedAt       int64
	DeletedBySender int64
	State           string
	SnoozedUntil    sql.NullInt64
	ReadAt          sql.NullInt64
	AckedAt         sql.NullInt64
}

func (q *Queries) GetSnoozedMessages(ctx context.Context, arg GetSnoozedMessagesParams) ([]GetSnoozedMessagesRow, error) {
	rows, err := q.db.QueryContext(ctx, GetSnoozedMessages, arg.AgentID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSnoozedMessagesRow
	for rows.Next() {
		var i GetSnoozedMessagesRow
		if err := rows.Scan(
			&i.ID,
			&i.ThreadID,
			&i.TopicID,
			&i.LogOffset,
			&i.SenderID,
			&i.Subject,
			&i.BodyMd,
			&i.Priority,
			&i.DeadlineAt,
			&i.Attachments,
			&i.CreatedAt,
			&i.DeletedBySender,
			&i.State,
			&i.SnoozedUntil,
			&i.ReadAt,
			&i.AckedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetSnoozedMessagesReadyToWake = `-- name: GetSnoozedMessagesReadyToWake :many
SELECT m.id, m.thread_id, m.topic_id, m.log_offset, m.sender_id, m.subject, m.body_md, m.priority, m.deadline_at, m.attachments, m.created_at, m.deleted_by_sender, mr.agent_id as recipient_agent_id
FROM messages m
JOIN message_recipients mr ON m.id = mr.message_id
WHERE mr.state = 'snoozed'
    AND mr.snoozed_until <= ?
ORDER BY mr.snoozed_until ASC
`

type GetSnoozedMessagesReadyToWakeRow struct {
	ID               int64
	ThreadID         string
	TopicID          int64
	LogOffset        int64
	SenderID         int64
	Subject          string
	BodyMd           string
	Priority         string
	DeadlineAt       sql.NullInt64
	Attachments      sql.NullString
	CreatedAt        int64
	DeletedBySender  int64
	RecipientAgentID int64
}

func (q *Queries) GetSnoozedMessagesReadyToWake(ctx context.Context, snoozedUntil sql.NullInt64) ([]GetSnoozedMessagesReadyToWakeRow, error) {
	rows, err := q.db.QueryContext(ctx, GetSnoozedMessagesReadyToWake, snoozedUntil)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSnoozedMessagesReadyToWakeRow
	for rows.Next() {
		var i GetSnoozedMessagesReadyToWakeRow
		if err := rows.Scan(
			&i.ID,
			&i.ThreadID,
			&i.TopicID,
			&i.LogOffset,
			&i.SenderID,
			&i.Subject,
			&i.BodyMd,
			&i.Priority,
			&i.DeadlineAt,
			&i.Attachments,
			&i.CreatedAt,
			&i.DeletedBySender,
			&i.RecipientAgentID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetStarredMessages = `-- name: GetStarredMessages :many
SELECT m.id, m.thread_id, m.topic_id, m.log_offset, m.sender_id, m.subject, m.body_md, m.priority, m.deadline_at, m.attachments, m.created_at, m.deleted_by_sender, mr.state, mr.snoozed_until, mr.read_at, mr.acked_at
FROM messages m
JOIN message_recipients mr ON m.id = mr.message_id
WHERE mr.agent_id = ?
    AND mr.state = 'starred'
ORDER BY m.created_at DESC
LIMIT ?
`

type GetStarredMessagesParams struct {
	AgentID int64
	Limit   int64
}

type GetStarredMessagesRow struct {
	ID              int64
	ThreadID        string
	TopicID         int64
	LogOffset       int64
	SenderID        int64
	Subject         string
	BodyMd          string
	Priority        string
	DeadlineAt      sql.NullInt64
	Attachments     sql.NullString
	CreatedAt       int64
	DeletedBySender int64
	State           string
	SnoozedUntil    sql.NullInt64
	ReadAt          sql.NullInt64
	AckedAt         sql.NullInt64
}

func (q *Queries) GetStarredMessages(ctx context.Context, arg GetStarredMessagesParams) ([]GetStarredMessagesRow, error) {
	rows, err := q.db.QueryContext(ctx, GetStarredMessages, arg.AgentID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetStarredMessagesRow
	for rows.Next() {
		var i GetStarredMessagesRow
		if err := rows.Scan(
			&i.ID,
			&i.ThreadID,
			&i.TopicID,
			&i.LogOffset,
			&i.SenderID,
			&i.Subject,
			&i.BodyMd,
			&i.Priority,
			&i.DeadlineAt,
			&i.Attachments,
			&i.CreatedAt,
			&i.DeletedBySender,
			&i.State,
			&i.SnoozedUntil,
			&i.ReadAt,
			&i.AckedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetTrashMessages = `-- name: GetTrashMessages :many
SELECT m.id, m.thread_id, m.topic_id, m.log_offset, m.sender_id, m.subject, m.body_md, m.priority, m.deadline_at, m.attachments, m.created_at, m.deleted_by_sender, mr.state, mr.snoozed_until, mr.read_at, mr.acked_at
FROM messages m
JOIN message_recipients mr ON m.id = mr.message_id
WHERE mr.agent_id = ?
    AND mr.state = 'trash'
ORDER BY m.created_at DESC
LIMIT ?
`

type GetTrashMessagesParams struct {
	AgentID int64
	Limit   int64
}

type GetTrashMessagesRow struct {
	ID              int64
	ThreadID        string
	TopicID         int64
	LogOffset       int64
	SenderID        int64
	Subject         string
	BodyMd          string
	Priority        string
	DeadlineAt      sql.NullInt64
	Attachments     sql.NullString
	CreatedAt       int64
	DeletedBySender int64
	State           string
	SnoozedUntil    sql.NullInt64
	ReadAt          sql.NullInt64
	AckedAt         sql.NullInt64
}

func (q *Queries) GetTrashMessages(ctx context.Context, arg GetTrashMessagesParams) ([]GetTrashMessagesRow, error) {
	rows, err := q.db.QueryContext(ctx, GetTrashMessages, arg.AgentID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTrashMessagesRow
	for rows.Next() {
		var i GetTrashMessagesRow
		if err := rows.Scan(
			&i.ID,
			&i.ThreadID,
			&i.TopicID,
			&i.LogOffset,
			&i.SenderID,
			&i.Subject,
			&i.BodyMd,
			&i.Priority,
			&i.DeadlineAt,
			&i.Attachments,
			&i.CreatedAt,
			&i.DeletedBySender,
			&i.State,
			&i.SnoozedUntil,
			&i.ReadAt,
			&i.AckedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetUnreadMessages = `-- name: GetUnreadMessages :many
SELECT m.id, m.thread_id, m.topic_id, m.log_offset, m.sender_id, m.subject, m.body_md, m.priority, m.deadline_at, m.attachments, m.created_at, m.deleted_by_sender, mr.state, mr.snoozed_until, mr.read_at, mr.acked_at
FROM messages m
JOIN message_recipients mr ON m.id = mr.message_id
WHERE mr.agent_id = ?
    AND mr.state = 'unread'
ORDER BY m.created_at DESC
LIMIT ?
`

type GetUnreadMessagesParams struct {
	AgentID int64
	Limit   int64
}

type GetUnreadMessagesRow struct {
	ID              int64
	ThreadID        string
	TopicID         int64
	LogOffset       int64
	SenderID        int64
	Subject         string
	BodyMd          string
	Priority        string
	DeadlineAt      sql.NullInt64
	Attachments     sql.NullString
	CreatedAt       int64
	DeletedBySender int64
	State           string
	SnoozedUntil    sql.NullInt64
	ReadAt          sql.NullInt64
	AckedAt         sql.NullInt64
}

func (q *Queries) GetUnreadMessages(ctx context.Context, arg GetUnreadMessagesParams) ([]GetUnreadMessagesRow, error) {
	rows, err := q.db.QueryContext(ctx, GetUnreadMessages, arg.AgentID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUnreadMessagesRow
	for rows.Next() {
		var i GetUnreadMessagesRow
		if err := rows.Scan(
			&i.ID,
			&i.ThreadID,
			&i.TopicID,
			&i.LogOffset,
			&i.SenderID,
			&i.Subject,
			&i.BodyMd,
			&i.Priority,
			&i.DeadlineAt,
			&i.Attachments,
			&i.CreatedAt,
			&i.DeletedBySender,
			&i.State,
			&i.SnoozedUntil,
			&i.ReadAt,
			&i.AckedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const HasUnackedStatusToAgent = `-- name: HasUnackedStatusToAgent :one
SELECT COUNT(*) FROM messages m
JOIN message_recipients mr ON m.id = mr.message_id
WHERE m.sender_id = ?
  AND mr.agent_id = ?
  AND mr.acked_at IS NULL
  AND m.subject LIKE '[Status]%'
`

type HasUnackedStatusToAgentParams struct {
	SenderID int64
	AgentID  int64
}

// Check if there are any unacked status messages from sender to recipient.
// Used for deduplication in status-update command.
func (q *Queries) HasUnackedStatusToAgent(ctx context.Context, arg HasUnackedStatusToAgentParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, HasUnackedStatusToAgent, arg.SenderID, arg.AgentID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const ListMessagesByPriority = `-- name: ListMessagesByPriority :many
SELECT m.id, m.thread_id, m.topic_id, m.log_offset, m.sender_id, m.subject, m.body_md, m.priority, m.deadline_at, m.attachments, m.created_at, m.deleted_by_sender FROM messages m
JOIN message_recipients mr ON m.id = mr.message_id
WHERE mr.agent_id = ? AND m.priority = ?
ORDER BY m.created_at DESC
LIMIT ?
`

type ListMessagesByPriorityParams struct {
	AgentID  int64
	Priority string
	Limit    int64
}

func (q *Queries) ListMessagesByPriority(ctx context.Context, arg ListMessagesByPriorityParams) ([]Message, error) {
	rows, err := q.db.QueryContext(ctx, ListMessagesByPriority, arg.AgentID, arg.Priority, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Message
	for rows.Next() {
		var i Message
		if err := rows.Scan(
			&i.ID,
			&i.ThreadID,
			&i.TopicID,
			&i.LogOffset,
			&i.SenderID,
			&i.Subject,
			&i.BodyMd,
			&i.Priority,
			&i.DeadlineAt,
			&i.Attachments,
			&i.CreatedAt,
			&i.DeletedBySender,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const MarkMessageDeletedBySender = `-- name: MarkMessageDeletedBySender :exec
UPDATE messages SET deleted_by_sender = 1 WHERE id = ? AND sender_id = ?
`

type MarkMessageDeletedBySenderParams struct {
	ID       int64
	SenderID int64
}

func (q *Queries) MarkMessageDeletedBySender(ctx context.Context, arg MarkMessageDeletedBySenderParams) error {
	_, err := q.db.ExecContext(ctx, MarkMessageDeletedBySender, arg.ID, arg.SenderID)
	return err
}

const UpdateRecipientAcked = `-- name: UpdateRecipientAcked :exec
UPDATE message_recipients
SET acked_at = ?
WHERE message_id = ? AND agent_id = ?
`

type UpdateRecipientAckedParams struct {
	AckedAt   sql.NullInt64
	MessageID int64
	AgentID   int64
}

func (q *Queries) UpdateRecipientAcked(ctx context.Context, arg UpdateRecipientAckedParams) error {
	_, err := q.db.ExecContext(ctx, UpdateRecipientAcked, arg.AckedAt, arg.MessageID, arg.AgentID)
	return err
}

const UpdateRecipientSnoozed = `-- name: UpdateRecipientSnoozed :exec
UPDATE message_recipients
SET state = 'snoozed', snoozed_until = ?
WHERE message_id = ? AND agent_id = ?
`

type UpdateRecipientSnoozedParams struct {
	SnoozedUntil sql.NullInt64
	MessageID    int64
	AgentID      int64
}

func (q *Queries) UpdateRecipientSnoozed(ctx context.Context, arg UpdateRecipientSnoozedParams) error {
	_, err := q.db.ExecContext(ctx, UpdateRecipientSnoozed, arg.SnoozedUntil, arg.MessageID, arg.AgentID)
	return err
}

const UpdateRecipientState = `-- name: UpdateRecipientState :execrows
UPDATE message_recipients
SET state = ?, read_at = CASE WHEN ? = 'read' THEN ? ELSE read_at END
WHERE message_id = ? AND agent_id = ?
`

type UpdateRecipientStateParams struct {
	State     string
	Column2   interface{}
	ReadAt    sql.NullInt64
	MessageID int64
	AgentID   int64
}

func (q *Queries) UpdateRecipientState(ctx context.Context, arg UpdateRecipientStateParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, UpdateRecipientState,
		arg.State,
		arg.Column2,
		arg.ReadAt,
		arg.MessageID,
		arg.AgentID,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const WakeSnoozedMessages = `-- name: WakeSnoozedMessages :execrows
UPDATE message_recipients
SET state = 'unread', snoozed_until = NULL
WHERE state = 'snoozed' AND snoozed_until <= ?
`

func (q *Queries) WakeSnoozedMessages(ctx context.Context, snoozedUntil sql.NullInt64) (int64, error) {
	result, err := q.db.ExecContext(ctx, WakeSnoozedMessages, snoozedUntil)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}
