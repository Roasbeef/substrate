// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queue.sql

package sqlc

import (
	"context"
	"database/sql"
)

const ClearAllOperations = `-- name: ClearAllOperations :exec
DELETE FROM pending_operations
`

func (q *Queries) ClearAllOperations(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, ClearAllOperations)
	return err
}

const CountPendingOperations = `-- name: CountPendingOperations :one
SELECT COUNT(*) FROM pending_operations WHERE status = 'pending'
`

func (q *Queries) CountPendingOperations(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, CountPendingOperations)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const DrainPendingOperations = `-- name: DrainPendingOperations :many
UPDATE pending_operations SET status = 'delivering'
WHERE status = 'pending' RETURNING id, idempotency_key, operation_type, payload_json, agent_name, session_id, created_at, expires_at, attempts, last_error, status
`

func (q *Queries) DrainPendingOperations(ctx context.Context) ([]PendingOperation, error) {
	rows, err := q.db.QueryContext(ctx, DrainPendingOperations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PendingOperation
	for rows.Next() {
		var i PendingOperation
		if err := rows.Scan(
			&i.ID,
			&i.IdempotencyKey,
			&i.OperationType,
			&i.PayloadJson,
			&i.AgentName,
			&i.SessionID,
			&i.CreatedAt,
			&i.ExpiresAt,
			&i.Attempts,
			&i.LastError,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const EnqueueOperation = `-- name: EnqueueOperation :one
INSERT INTO pending_operations (
    idempotency_key, operation_type, payload_json, agent_name,
    session_id, created_at, expires_at
) VALUES (?, ?, ?, ?, ?, ?, ?)
RETURNING id, idempotency_key, operation_type, payload_json, agent_name, session_id, created_at, expires_at, attempts, last_error, status
`

type EnqueueOperationParams struct {
	IdempotencyKey string
	OperationType  string
	PayloadJson    string
	AgentName      string
	SessionID      sql.NullString
	CreatedAt      int64
	ExpiresAt      int64
}

func (q *Queries) EnqueueOperation(ctx context.Context, arg EnqueueOperationParams) (PendingOperation, error) {
	row := q.db.QueryRowContext(ctx, EnqueueOperation,
		arg.IdempotencyKey,
		arg.OperationType,
		arg.PayloadJson,
		arg.AgentName,
		arg.SessionID,
		arg.CreatedAt,
		arg.ExpiresAt,
	)
	var i PendingOperation
	err := row.Scan(
		&i.ID,
		&i.IdempotencyKey,
		&i.OperationType,
		&i.PayloadJson,
		&i.AgentName,
		&i.SessionID,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.Attempts,
		&i.LastError,
		&i.Status,
	)
	return i, err
}

const GetQueueStats = `-- name: GetQueueStats :one
SELECT
    COUNT(CASE WHEN status = 'pending' THEN 1 END) AS pending_count,
    COUNT(CASE WHEN status = 'delivered' THEN 1 END) AS delivered_count,
    COUNT(CASE WHEN status = 'expired' THEN 1 END) AS expired_count,
    COUNT(CASE WHEN status = 'failed' THEN 1 END) AS failed_count,
    MIN(CASE WHEN status = 'pending' THEN created_at END) AS oldest_pending
FROM pending_operations
`

type GetQueueStatsRow struct {
	PendingCount   int64
	DeliveredCount int64
	ExpiredCount   int64
	FailedCount    int64
	OldestPending  interface{}
}

func (q *Queries) GetQueueStats(ctx context.Context) (GetQueueStatsRow, error) {
	row := q.db.QueryRowContext(ctx, GetQueueStats)
	var i GetQueueStatsRow
	err := row.Scan(
		&i.PendingCount,
		&i.DeliveredCount,
		&i.ExpiredCount,
		&i.FailedCount,
		&i.OldestPending,
	)
	return i, err
}

const ListPendingOperations = `-- name: ListPendingOperations :many
SELECT id, idempotency_key, operation_type, payload_json, agent_name, session_id, created_at, expires_at, attempts, last_error, status FROM pending_operations
WHERE status = 'pending' ORDER BY created_at ASC
`

func (q *Queries) ListPendingOperations(ctx context.Context) ([]PendingOperation, error) {
	rows, err := q.db.QueryContext(ctx, ListPendingOperations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PendingOperation
	for rows.Next() {
		var i PendingOperation
		if err := rows.Scan(
			&i.ID,
			&i.IdempotencyKey,
			&i.OperationType,
			&i.PayloadJson,
			&i.AgentName,
			&i.SessionID,
			&i.CreatedAt,
			&i.ExpiresAt,
			&i.Attempts,
			&i.LastError,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const MarkOperationDelivered = `-- name: MarkOperationDelivered :exec
UPDATE pending_operations SET status = 'delivered' WHERE id = ?
`

func (q *Queries) MarkOperationDelivered(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, MarkOperationDelivered, id)
	return err
}

const MarkOperationFailed = `-- name: MarkOperationFailed :exec
UPDATE pending_operations
SET status = 'pending', attempts = attempts + 1, last_error = ?
WHERE id = ?
`

type MarkOperationFailedParams struct {
	LastError sql.NullString
	ID        int64
}

func (q *Queries) MarkOperationFailed(ctx context.Context, arg MarkOperationFailedParams) error {
	_, err := q.db.ExecContext(ctx, MarkOperationFailed, arg.LastError, arg.ID)
	return err
}

const PurgeExpiredOperations = `-- name: PurgeExpiredOperations :execrows
DELETE FROM pending_operations
WHERE expires_at < ? AND status IN ('pending', 'failed')
`

func (q *Queries) PurgeExpiredOperations(ctx context.Context, expiresAt int64) (int64, error) {
	result, err := q.db.ExecContext(ctx, PurgeExpiredOperations, expiresAt)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}
