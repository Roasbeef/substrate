// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: reviews.sql

package sqlc

import (
	"context"
	"database/sql"
)

const BulkResolveIssues = `-- name: BulkResolveIssues :exec
UPDATE review_issues
SET status = 'fixed', resolved_at = ?, resolved_in_iteration = ?
WHERE review_id = ? AND id IN (/*SLICE:issue_ids*/?)
`

type BulkResolveIssuesParams struct {
	ResolvedAt          sql.NullInt64
	ResolvedInIteration sql.NullInt64
	ReviewID            string
	IssueIds            []int64
}

func (q *Queries) BulkResolveIssues(ctx context.Context, arg BulkResolveIssuesParams) error {
	query := BulkResolveIssues
	var queryParams []interface{}
	queryParams = append(queryParams, arg.ResolvedAt)
	queryParams = append(queryParams, arg.ResolvedInIteration)
	queryParams = append(queryParams, arg.ReviewID)
	if len(arg.IssueIds) > 0 {
		for _, v := range arg.IssueIds {
			queryParams = append(queryParams, v)
		}
		query = replaceSlice(query, "/*SLICE:issue_ids*/?", len(arg.IssueIds))
	}
	_, err := q.db.ExecContext(ctx, query, queryParams...)
	return err
}

const CompleteReview = `-- name: CompleteReview :exec
UPDATE reviews
SET state = ?, completed_at = ?, updated_at = ?
WHERE review_id = ?
`

type CompleteReviewParams struct {
	State       string
	CompletedAt sql.NullInt64
	UpdatedAt   int64
	ReviewID    string
}

func (q *Queries) CompleteReview(ctx context.Context, arg CompleteReviewParams) error {
	_, err := q.db.ExecContext(ctx, CompleteReview, arg.State, arg.CompletedAt, arg.UpdatedAt, arg.ReviewID)
	return err
}

const CountIssuesBySeverity = `-- name: CountIssuesBySeverity :many
SELECT severity, COUNT(*) as count
FROM review_issues
WHERE review_id = ?
GROUP BY severity
`

type CountIssuesBySeverityRow struct {
	Severity string
	Count    int64
}

func (q *Queries) CountIssuesBySeverity(ctx context.Context, reviewID string) ([]CountIssuesBySeverityRow, error) {
	rows, err := q.db.QueryContext(ctx, CountIssuesBySeverity, reviewID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CountIssuesBySeverityRow
	for rows.Next() {
		var i CountIssuesBySeverityRow
		if err := rows.Scan(&i.Severity, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const CountIssuesByType = `-- name: CountIssuesByType :many
SELECT issue_type, COUNT(*) as count
FROM review_issues
WHERE review_id = ?
GROUP BY issue_type
`

type CountIssuesByTypeRow struct {
	IssueType string
	Count     int64
}

func (q *Queries) CountIssuesByType(ctx context.Context, reviewID string) ([]CountIssuesByTypeRow, error) {
	rows, err := q.db.QueryContext(ctx, CountIssuesByType, reviewID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CountIssuesByTypeRow
	for rows.Next() {
		var i CountIssuesByTypeRow
		if err := rows.Scan(&i.IssueType, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const CountIterationsByDecision = `-- name: CountIterationsByDecision :one
SELECT
    SUM(CASE WHEN decision = 'approve' THEN 1 ELSE 0 END) as approvals,
    SUM(CASE WHEN decision = 'request_changes' THEN 1 ELSE 0 END) as change_requests,
    SUM(CASE WHEN decision = 'comment' THEN 1 ELSE 0 END) as comments
FROM review_iterations
WHERE review_id = ? AND iteration_num = ?
`

type CountIterationsByDecisionParams struct {
	ReviewID     string
	IterationNum int64
}

type CountIterationsByDecisionRow struct {
	Approvals      interface{}
	ChangeRequests interface{}
	Comments       interface{}
}

func (q *Queries) CountIterationsByDecision(ctx context.Context, arg CountIterationsByDecisionParams) (CountIterationsByDecisionRow, error) {
	row := q.db.QueryRowContext(ctx, CountIterationsByDecision, arg.ReviewID, arg.IterationNum)
	var i CountIterationsByDecisionRow
	err := row.Scan(&i.Approvals, &i.ChangeRequests, &i.Comments)
	return i, err
}

const CountOpenIssues = `-- name: CountOpenIssues :one
SELECT COUNT(*) FROM review_issues
WHERE review_id = ? AND status = 'open'
`

func (q *Queries) CountOpenIssues(ctx context.Context, reviewID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, CountOpenIssues, reviewID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CountOpenReviewsByRequester = `-- name: CountOpenReviewsByRequester :one
SELECT COUNT(*) FROM reviews
WHERE requester_id = ?
  AND state NOT IN ('approved', 'rejected', 'cancelled')
`

func (q *Queries) CountOpenReviewsByRequester(ctx context.Context, requesterID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, CountOpenReviewsByRequester, requesterID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CountReviewsByState = `-- name: CountReviewsByState :one
SELECT COUNT(*) FROM reviews WHERE state = ?
`

func (q *Queries) CountReviewsByState(ctx context.Context, state string) (int64, error) {
	row := q.db.QueryRowContext(ctx, CountReviewsByState, state)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CreateReview = `-- name: CreateReview :one
INSERT INTO reviews (
    review_id, thread_id, requester_id, pr_number, branch, base_branch,
    commit_sha, repo_path, review_type, priority, state, created_at, updated_at
)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, review_id, thread_id, requester_id, pr_number, branch, base_branch, commit_sha, repo_path, review_type, priority, state, created_at, updated_at, completed_at
`

type CreateReviewParams struct {
	ReviewID    string
	ThreadID    string
	RequesterID int64
	PrNumber    sql.NullInt64
	Branch      string
	BaseBranch  string
	CommitSha   string
	RepoPath    string
	ReviewType  string
	Priority    string
	State       string
	CreatedAt   int64
	UpdatedAt   int64
}

func (q *Queries) CreateReview(ctx context.Context, arg CreateReviewParams) (Review, error) {
	row := q.db.QueryRowContext(ctx, CreateReview,
		arg.ReviewID,
		arg.ThreadID,
		arg.RequesterID,
		arg.PrNumber,
		arg.Branch,
		arg.BaseBranch,
		arg.CommitSha,
		arg.RepoPath,
		arg.ReviewType,
		arg.Priority,
		arg.State,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i Review
	err := row.Scan(
		&i.ID,
		&i.ReviewID,
		&i.ThreadID,
		&i.RequesterID,
		&i.PrNumber,
		&i.Branch,
		&i.BaseBranch,
		&i.CommitSha,
		&i.RepoPath,
		&i.ReviewType,
		&i.Priority,
		&i.State,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
	)
	return i, err
}

const CreateReviewIssue = `-- name: CreateReviewIssue :one
INSERT INTO review_issues (
    review_id, iteration_num, issue_type, severity, file_path, line_start,
    line_end, title, description, code_snippet, suggestion, claude_md_ref,
    status, created_at
)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, review_id, iteration_num, issue_type, severity, file_path, line_start, line_end, title, description, code_snippet, suggestion, claude_md_ref, status, resolved_at, resolved_in_iteration, created_at
`

type CreateReviewIssueParams struct {
	ReviewID     string
	IterationNum int64
	IssueType    string
	Severity     string
	FilePath     string
	LineStart    int64
	LineEnd      sql.NullInt64
	Title        string
	Description  string
	CodeSnippet  sql.NullString
	Suggestion   sql.NullString
	ClaudeMdRef  sql.NullString
	Status       string
	CreatedAt    int64
}

func (q *Queries) CreateReviewIssue(ctx context.Context, arg CreateReviewIssueParams) (ReviewIssue, error) {
	row := q.db.QueryRowContext(ctx, CreateReviewIssue,
		arg.ReviewID,
		arg.IterationNum,
		arg.IssueType,
		arg.Severity,
		arg.FilePath,
		arg.LineStart,
		arg.LineEnd,
		arg.Title,
		arg.Description,
		arg.CodeSnippet,
		arg.Suggestion,
		arg.ClaudeMdRef,
		arg.Status,
		arg.CreatedAt,
	)
	var i ReviewIssue
	err := row.Scan(
		&i.ID,
		&i.ReviewID,
		&i.IterationNum,
		&i.IssueType,
		&i.Severity,
		&i.FilePath,
		&i.LineStart,
		&i.LineEnd,
		&i.Title,
		&i.Description,
		&i.CodeSnippet,
		&i.Suggestion,
		&i.ClaudeMdRef,
		&i.Status,
		&i.ResolvedAt,
		&i.ResolvedInIteration,
		&i.CreatedAt,
	)
	return i, err
}

const CreateReviewIteration = `-- name: CreateReviewIteration :one
INSERT INTO review_iterations (
    review_id, iteration_num, reviewer_id, reviewer_session_id, decision,
    summary, issues_json, suggestions_json, files_reviewed, lines_analyzed,
    duration_ms, cost_usd, started_at, completed_at
)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, review_id, iteration_num, reviewer_id, reviewer_session_id, decision, summary, issues_json, suggestions_json, files_reviewed, lines_analyzed, duration_ms, cost_usd, started_at, completed_at
`

type CreateReviewIterationParams struct {
	ReviewID          string
	IterationNum      int64
	ReviewerID        string
	ReviewerSessionID sql.NullString
	Decision          string
	Summary           string
	IssuesJson        sql.NullString
	SuggestionsJson   sql.NullString
	FilesReviewed     int64
	LinesAnalyzed     int64
	DurationMs        int64
	CostUsd           float64
	StartedAt         int64
	CompletedAt       sql.NullInt64
}

func (q *Queries) CreateReviewIteration(ctx context.Context, arg CreateReviewIterationParams) (ReviewIteration, error) {
	row := q.db.QueryRowContext(ctx, CreateReviewIteration,
		arg.ReviewID,
		arg.IterationNum,
		arg.ReviewerID,
		arg.ReviewerSessionID,
		arg.Decision,
		arg.Summary,
		arg.IssuesJson,
		arg.SuggestionsJson,
		arg.FilesReviewed,
		arg.LinesAnalyzed,
		arg.DurationMs,
		arg.CostUsd,
		arg.StartedAt,
		arg.CompletedAt,
	)
	var i ReviewIteration
	err := row.Scan(
		&i.ID,
		&i.ReviewID,
		&i.IterationNum,
		&i.ReviewerID,
		&i.ReviewerSessionID,
		&i.Decision,
		&i.Summary,
		&i.IssuesJson,
		&i.SuggestionsJson,
		&i.FilesReviewed,
		&i.LinesAnalyzed,
		&i.DurationMs,
		&i.CostUsd,
		&i.StartedAt,
		&i.CompletedAt,
	)
	return i, err
}

const DeleteReview = `-- name: DeleteReview :exec
DELETE FROM reviews WHERE review_id = ?
`

func (q *Queries) DeleteReview(ctx context.Context, reviewID string) error {
	_, err := q.db.ExecContext(ctx, DeleteReview, reviewID)
	return err
}

const DeleteReviewIssues = `-- name: DeleteReviewIssues :exec
DELETE FROM review_issues WHERE review_id = ?
`

func (q *Queries) DeleteReviewIssues(ctx context.Context, reviewID string) error {
	_, err := q.db.ExecContext(ctx, DeleteReviewIssues, reviewID)
	return err
}

const GetAverageIterationsToApproval = `-- name: GetAverageIterationsToApproval :one
SELECT AVG(iteration_count) as avg_iterations
FROM (
    SELECT review_id, MAX(iteration_num) as iteration_count
    FROM review_iterations
    WHERE review_id IN (SELECT review_id FROM reviews WHERE state = 'approved')
    GROUP BY review_id
)
`

func (q *Queries) GetAverageIterationsToApproval(ctx context.Context) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, GetAverageIterationsToApproval)
	var avg_iterations interface{}
	err := row.Scan(&avg_iterations)
	return avg_iterations, err
}

const GetIterationCount = `-- name: GetIterationCount :one
SELECT COALESCE(MAX(iteration_num), 0) as max_iteration
FROM review_iterations
WHERE review_id = ?
`

func (q *Queries) GetIterationCount(ctx context.Context, reviewID string) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, GetIterationCount, reviewID)
	var max_iteration interface{}
	err := row.Scan(&max_iteration)
	return max_iteration, err
}

const GetLatestReviewIteration = `-- name: GetLatestReviewIteration :one
SELECT id, review_id, iteration_num, reviewer_id, reviewer_session_id, decision, summary, issues_json, suggestions_json, files_reviewed, lines_analyzed, duration_ms, cost_usd, started_at, completed_at FROM review_iterations
WHERE review_id = ?
ORDER BY iteration_num DESC, started_at DESC
LIMIT 1
`

func (q *Queries) GetLatestReviewIteration(ctx context.Context, reviewID string) (ReviewIteration, error) {
	row := q.db.QueryRowContext(ctx, GetLatestReviewIteration, reviewID)
	var i ReviewIteration
	err := row.Scan(
		&i.ID,
		&i.ReviewID,
		&i.IterationNum,
		&i.ReviewerID,
		&i.ReviewerSessionID,
		&i.Decision,
		&i.Summary,
		&i.IssuesJson,
		&i.SuggestionsJson,
		&i.FilesReviewed,
		&i.LinesAnalyzed,
		&i.DurationMs,
		&i.CostUsd,
		&i.StartedAt,
		&i.CompletedAt,
	)
	return i, err
}

const GetReview = `-- name: GetReview :one
SELECT id, review_id, thread_id, requester_id, pr_number, branch, base_branch, commit_sha, repo_path, review_type, priority, state, created_at, updated_at, completed_at FROM reviews WHERE review_id = ?
`

func (q *Queries) GetReview(ctx context.Context, reviewID string) (Review, error) {
	row := q.db.QueryRowContext(ctx, GetReview, reviewID)
	var i Review
	err := row.Scan(
		&i.ID,
		&i.ReviewID,
		&i.ThreadID,
		&i.RequesterID,
		&i.PrNumber,
		&i.Branch,
		&i.BaseBranch,
		&i.CommitSha,
		&i.RepoPath,
		&i.ReviewType,
		&i.Priority,
		&i.State,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
	)
	return i, err
}

const GetReviewByID = `-- name: GetReviewByID :one
SELECT id, review_id, thread_id, requester_id, pr_number, branch, base_branch, commit_sha, repo_path, review_type, priority, state, created_at, updated_at, completed_at FROM reviews WHERE id = ?
`

func (q *Queries) GetReviewByID(ctx context.Context, id int64) (Review, error) {
	row := q.db.QueryRowContext(ctx, GetReviewByID, id)
	var i Review
	err := row.Scan(
		&i.ID,
		&i.ReviewID,
		&i.ThreadID,
		&i.RequesterID,
		&i.PrNumber,
		&i.Branch,
		&i.BaseBranch,
		&i.CommitSha,
		&i.RepoPath,
		&i.ReviewType,
		&i.Priority,
		&i.State,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
	)
	return i, err
}

const GetReviewByThread = `-- name: GetReviewByThread :one
SELECT id, review_id, thread_id, requester_id, pr_number, branch, base_branch, commit_sha, repo_path, review_type, priority, state, created_at, updated_at, completed_at FROM reviews WHERE thread_id = ?
`

func (q *Queries) GetReviewByThread(ctx context.Context, threadID string) (Review, error) {
	row := q.db.QueryRowContext(ctx, GetReviewByThread, threadID)
	var i Review
	err := row.Scan(
		&i.ID,
		&i.ReviewID,
		&i.ThreadID,
		&i.RequesterID,
		&i.PrNumber,
		&i.Branch,
		&i.BaseBranch,
		&i.CommitSha,
		&i.RepoPath,
		&i.ReviewType,
		&i.Priority,
		&i.State,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
	)
	return i, err
}

const GetReviewIssue = `-- name: GetReviewIssue :one
SELECT id, review_id, iteration_num, issue_type, severity, file_path, line_start, line_end, title, description, code_snippet, suggestion, claude_md_ref, status, resolved_at, resolved_in_iteration, created_at FROM review_issues WHERE id = ?
`

func (q *Queries) GetReviewIssue(ctx context.Context, id int64) (ReviewIssue, error) {
	row := q.db.QueryRowContext(ctx, GetReviewIssue, id)
	var i ReviewIssue
	err := row.Scan(
		&i.ID,
		&i.ReviewID,
		&i.IterationNum,
		&i.IssueType,
		&i.Severity,
		&i.FilePath,
		&i.LineStart,
		&i.LineEnd,
		&i.Title,
		&i.Description,
		&i.CodeSnippet,
		&i.Suggestion,
		&i.ClaudeMdRef,
		&i.Status,
		&i.ResolvedAt,
		&i.ResolvedInIteration,
		&i.CreatedAt,
	)
	return i, err
}

const GetReviewIteration = `-- name: GetReviewIteration :one
SELECT id, review_id, iteration_num, reviewer_id, reviewer_session_id, decision, summary, issues_json, suggestions_json, files_reviewed, lines_analyzed, duration_ms, cost_usd, started_at, completed_at FROM review_iterations
WHERE review_id = ? AND iteration_num = ? AND reviewer_id = ?
`

type GetReviewIterationParams struct {
	ReviewID     string
	IterationNum int64
	ReviewerID   string
}

func (q *Queries) GetReviewIteration(ctx context.Context, arg GetReviewIterationParams) (ReviewIteration, error) {
	row := q.db.QueryRowContext(ctx, GetReviewIteration, arg.ReviewID, arg.IterationNum, arg.ReviewerID)
	var i ReviewIteration
	err := row.Scan(
		&i.ID,
		&i.ReviewID,
		&i.IterationNum,
		&i.ReviewerID,
		&i.ReviewerSessionID,
		&i.Decision,
		&i.Summary,
		&i.IssuesJson,
		&i.SuggestionsJson,
		&i.FilesReviewed,
		&i.LinesAnalyzed,
		&i.DurationMs,
		&i.CostUsd,
		&i.StartedAt,
		&i.CompletedAt,
	)
	return i, err
}

const GetReviewStats = `-- name: GetReviewStats :one
SELECT
    COUNT(*) as total_reviews,
    SUM(CASE WHEN state = 'approved' THEN 1 ELSE 0 END) as approved,
    SUM(CASE WHEN state IN ('new', 'pending_review', 're_review') THEN 1 ELSE 0 END) as pending,
    SUM(CASE WHEN state = 'under_review' THEN 1 ELSE 0 END) as in_progress,
    SUM(CASE WHEN state = 'changes_requested' THEN 1 ELSE 0 END) as changes_requested
FROM reviews
`

type GetReviewStatsRow struct {
	TotalReviews     int64
	Approved         interface{}
	Pending          interface{}
	InProgress       interface{}
	ChangesRequested interface{}
}

func (q *Queries) GetReviewStats(ctx context.Context) (GetReviewStatsRow, error) {
	row := q.db.QueryRowContext(ctx, GetReviewStats)
	var i GetReviewStatsRow
	err := row.Scan(
		&i.TotalReviews,
		&i.Approved,
		&i.Pending,
		&i.InProgress,
		&i.ChangesRequested,
	)
	return i, err
}

const GetReviewStatsForRequester = `-- name: GetReviewStatsForRequester :one
SELECT
    COUNT(*) as total_reviews,
    SUM(CASE WHEN state = 'approved' THEN 1 ELSE 0 END) as approved,
    SUM(CASE WHEN state IN ('new', 'pending_review', 're_review') THEN 1 ELSE 0 END) as pending,
    SUM(CASE WHEN state = 'changes_requested' THEN 1 ELSE 0 END) as changes_requested
FROM reviews
WHERE requester_id = ?
`

type GetReviewStatsForRequesterRow struct {
	TotalReviews     int64
	Approved         interface{}
	Pending          interface{}
	ChangesRequested interface{}
}

func (q *Queries) GetReviewStatsForRequester(ctx context.Context, requesterID int64) (GetReviewStatsForRequesterRow, error) {
	row := q.db.QueryRowContext(ctx, GetReviewStatsForRequester, requesterID)
	var i GetReviewStatsForRequesterRow
	err := row.Scan(
		&i.TotalReviews,
		&i.Approved,
		&i.Pending,
		&i.ChangesRequested,
	)
	return i, err
}

const GetReviewerDecisions = `-- name: GetReviewerDecisions :many
SELECT reviewer_id, decision
FROM review_iterations
WHERE review_id = ? AND iteration_num = ?
`

type GetReviewerDecisionsParams struct {
	ReviewID     string
	IterationNum int64
}

type GetReviewerDecisionsRow struct {
	ReviewerID string
	Decision   string
}

func (q *Queries) GetReviewerDecisions(ctx context.Context, arg GetReviewerDecisionsParams) ([]GetReviewerDecisionsRow, error) {
	rows, err := q.db.QueryContext(ctx, GetReviewerDecisions, arg.ReviewID, arg.IterationNum)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetReviewerDecisionsRow
	for rows.Next() {
		var i GetReviewerDecisionsRow
		if err := rows.Scan(&i.ReviewerID, &i.Decision); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetReviewerStats = `-- name: GetReviewerStats :one
SELECT
    COUNT(DISTINCT review_id) as reviews_performed,
    SUM(CASE WHEN decision = 'approve' THEN 1 ELSE 0 END) as approvals,
    SUM(CASE WHEN decision = 'request_changes' THEN 1 ELSE 0 END) as change_requests,
    AVG(duration_ms) as avg_duration_ms,
    SUM(cost_usd) as total_cost
FROM review_iterations
WHERE reviewer_id = ?
`

type GetReviewerStatsRow struct {
	ReviewsPerformed int64
	Approvals        interface{}
	ChangeRequests   interface{}
	AvgDurationMs    interface{}
	TotalCost        interface{}
}

func (q *Queries) GetReviewerStats(ctx context.Context, reviewerID string) (GetReviewerStatsRow, error) {
	row := q.db.QueryRowContext(ctx, GetReviewerStats, reviewerID)
	var i GetReviewerStatsRow
	err := row.Scan(
		&i.ReviewsPerformed,
		&i.Approvals,
		&i.ChangeRequests,
		&i.AvgDurationMs,
		&i.TotalCost,
	)
	return i, err
}

const ListActiveReviews = `-- name: ListActiveReviews :many
SELECT id, review_id, thread_id, requester_id, pr_number, branch, base_branch, commit_sha, repo_path, review_type, priority, state, created_at, updated_at, completed_at FROM reviews
WHERE state NOT IN ('approved', 'rejected', 'cancelled')
ORDER BY updated_at DESC
LIMIT ?
`

func (q *Queries) ListActiveReviews(ctx context.Context, limit int64) ([]Review, error) {
	rows, err := q.db.QueryContext(ctx, ListActiveReviews, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Review
	for rows.Next() {
		var i Review
		if err := rows.Scan(
			&i.ID,
			&i.ReviewID,
			&i.ThreadID,
			&i.RequesterID,
			&i.PrNumber,
			&i.Branch,
			&i.BaseBranch,
			&i.CommitSha,
			&i.RepoPath,
			&i.ReviewType,
			&i.Priority,
			&i.State,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListOpenReviewIssues = `-- name: ListOpenReviewIssues :many
SELECT id, review_id, iteration_num, issue_type, severity, file_path, line_start, line_end, title, description, code_snippet, suggestion, claude_md_ref, status, resolved_at, resolved_in_iteration, created_at FROM review_issues
WHERE review_id = ? AND status = 'open'
ORDER BY severity, file_path, line_start
`

func (q *Queries) ListOpenReviewIssues(ctx context.Context, reviewID string) ([]ReviewIssue, error) {
	rows, err := q.db.QueryContext(ctx, ListOpenReviewIssues, reviewID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ReviewIssue
	for rows.Next() {
		var i ReviewIssue
		if err := rows.Scan(
			&i.ID,
			&i.ReviewID,
			&i.IterationNum,
			&i.IssueType,
			&i.Severity,
			&i.FilePath,
			&i.LineStart,
			&i.LineEnd,
			&i.Title,
			&i.Description,
			&i.CodeSnippet,
			&i.Suggestion,
			&i.ClaudeMdRef,
			&i.Status,
			&i.ResolvedAt,
			&i.ResolvedInIteration,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListPendingReviews = `-- name: ListPendingReviews :many
SELECT id, review_id, thread_id, requester_id, pr_number, branch, base_branch, commit_sha, repo_path, review_type, priority, state, created_at, updated_at, completed_at FROM reviews
WHERE state IN ('new', 'pending_review', 're_review')
ORDER BY
    CASE priority
        WHEN 'urgent' THEN 1
        WHEN 'normal' THEN 2
        WHEN 'low' THEN 3
    END,
    created_at ASC
LIMIT ?
`

func (q *Queries) ListPendingReviews(ctx context.Context, limit int64) ([]Review, error) {
	rows, err := q.db.QueryContext(ctx, ListPendingReviews, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Review
	for rows.Next() {
		var i Review
		if err := rows.Scan(
			&i.ID,
			&i.ReviewID,
			&i.ThreadID,
			&i.RequesterID,
			&i.PrNumber,
			&i.Branch,
			&i.BaseBranch,
			&i.CommitSha,
			&i.RepoPath,
			&i.ReviewType,
			&i.Priority,
			&i.State,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListReviewIssues = `-- name: ListReviewIssues :many
SELECT id, review_id, iteration_num, issue_type, severity, file_path, line_start, line_end, title, description, code_snippet, suggestion, claude_md_ref, status, resolved_at, resolved_in_iteration, created_at FROM review_issues
WHERE review_id = ?
ORDER BY
    CASE severity
        WHEN 'critical' THEN 1
        WHEN 'high' THEN 2
        WHEN 'medium' THEN 3
        WHEN 'low' THEN 4
    END,
    file_path, line_start
`

func (q *Queries) ListReviewIssues(ctx context.Context, reviewID string) ([]ReviewIssue, error) {
	rows, err := q.db.QueryContext(ctx, ListReviewIssues, reviewID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ReviewIssue
	for rows.Next() {
		var i ReviewIssue
		if err := rows.Scan(
			&i.ID,
			&i.ReviewID,
			&i.IterationNum,
			&i.IssueType,
			&i.Severity,
			&i.FilePath,
			&i.LineStart,
			&i.LineEnd,
			&i.Title,
			&i.Description,
			&i.CodeSnippet,
			&i.Suggestion,
			&i.ClaudeMdRef,
			&i.Status,
			&i.ResolvedAt,
			&i.ResolvedInIteration,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListReviewIssuesByFile = `-- name: ListReviewIssuesByFile :many
SELECT id, review_id, iteration_num, issue_type, severity, file_path, line_start, line_end, title, description, code_snippet, suggestion, claude_md_ref, status, resolved_at, resolved_in_iteration, created_at FROM review_issues
WHERE review_id = ? AND file_path = ?
ORDER BY line_start
`

type ListReviewIssuesByFileParams struct {
	ReviewID string
	FilePath string
}

func (q *Queries) ListReviewIssuesByFile(ctx context.Context, arg ListReviewIssuesByFileParams) ([]ReviewIssue, error) {
	rows, err := q.db.QueryContext(ctx, ListReviewIssuesByFile, arg.ReviewID, arg.FilePath)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ReviewIssue
	for rows.Next() {
		var i ReviewIssue
		if err := rows.Scan(
			&i.ID,
			&i.ReviewID,
			&i.IterationNum,
			&i.IssueType,
			&i.Severity,
			&i.FilePath,
			&i.LineStart,
			&i.LineEnd,
			&i.Title,
			&i.Description,
			&i.CodeSnippet,
			&i.Suggestion,
			&i.ClaudeMdRef,
			&i.Status,
			&i.ResolvedAt,
			&i.ResolvedInIteration,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListReviewIssuesByIteration = `-- name: ListReviewIssuesByIteration :many
SELECT id, review_id, iteration_num, issue_type, severity, file_path, line_start, line_end, title, description, code_snippet, suggestion, claude_md_ref, status, resolved_at, resolved_in_iteration, created_at FROM review_issues
WHERE review_id = ? AND iteration_num = ?
ORDER BY severity, file_path, line_start
`

type ListReviewIssuesByIterationParams struct {
	ReviewID     string
	IterationNum int64
}

func (q *Queries) ListReviewIssuesByIteration(ctx context.Context, arg ListReviewIssuesByIterationParams) ([]ReviewIssue, error) {
	rows, err := q.db.QueryContext(ctx, ListReviewIssuesByIteration, arg.ReviewID, arg.IterationNum)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ReviewIssue
	for rows.Next() {
		var i ReviewIssue
		if err := rows.Scan(
			&i.ID,
			&i.ReviewID,
			&i.IterationNum,
			&i.IssueType,
			&i.Severity,
			&i.FilePath,
			&i.LineStart,
			&i.LineEnd,
			&i.Title,
			&i.Description,
			&i.CodeSnippet,
			&i.Suggestion,
			&i.ClaudeMdRef,
			&i.Status,
			&i.ResolvedAt,
			&i.ResolvedInIteration,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListReviewIssuesBySeverity = `-- name: ListReviewIssuesBySeverity :many
SELECT id, review_id, iteration_num, issue_type, severity, file_path, line_start, line_end, title, description, code_snippet, suggestion, claude_md_ref, status, resolved_at, resolved_in_iteration, created_at FROM review_issues
WHERE review_id = ? AND severity = ?
ORDER BY file_path, line_start
`

type ListReviewIssuesBySeverityParams struct {
	ReviewID string
	Severity string
}

func (q *Queries) ListReviewIssuesBySeverity(ctx context.Context, arg ListReviewIssuesBySeverityParams) ([]ReviewIssue, error) {
	rows, err := q.db.QueryContext(ctx, ListReviewIssuesBySeverity, arg.ReviewID, arg.Severity)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ReviewIssue
	for rows.Next() {
		var i ReviewIssue
		if err := rows.Scan(
			&i.ID,
			&i.ReviewID,
			&i.IterationNum,
			&i.IssueType,
			&i.Severity,
			&i.FilePath,
			&i.LineStart,
			&i.LineEnd,
			&i.Title,
			&i.Description,
			&i.CodeSnippet,
			&i.Suggestion,
			&i.ClaudeMdRef,
			&i.Status,
			&i.ResolvedAt,
			&i.ResolvedInIteration,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListReviewIterations = `-- name: ListReviewIterations :many
SELECT id, review_id, iteration_num, reviewer_id, reviewer_session_id, decision, summary, issues_json, suggestions_json, files_reviewed, lines_analyzed, duration_ms, cost_usd, started_at, completed_at FROM review_iterations
WHERE review_id = ?
ORDER BY iteration_num ASC, started_at ASC
`

func (q *Queries) ListReviewIterations(ctx context.Context, reviewID string) ([]ReviewIteration, error) {
	rows, err := q.db.QueryContext(ctx, ListReviewIterations, reviewID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ReviewIteration
	for rows.Next() {
		var i ReviewIteration
		if err := rows.Scan(
			&i.ID,
			&i.ReviewID,
			&i.IterationNum,
			&i.ReviewerID,
			&i.ReviewerSessionID,
			&i.Decision,
			&i.Summary,
			&i.IssuesJson,
			&i.SuggestionsJson,
			&i.FilesReviewed,
			&i.LinesAnalyzed,
			&i.DurationMs,
			&i.CostUsd,
			&i.StartedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListReviewIterationsByReviewer = `-- name: ListReviewIterationsByReviewer :many
SELECT id, review_id, iteration_num, reviewer_id, reviewer_session_id, decision, summary, issues_json, suggestions_json, files_reviewed, lines_analyzed, duration_ms, cost_usd, started_at, completed_at FROM review_iterations
WHERE reviewer_id = ?
ORDER BY started_at DESC
LIMIT ?
`

type ListReviewIterationsByReviewerParams struct {
	ReviewerID string
	Limit      int64
}

func (q *Queries) ListReviewIterationsByReviewer(ctx context.Context, arg ListReviewIterationsByReviewerParams) ([]ReviewIteration, error) {
	rows, err := q.db.QueryContext(ctx, ListReviewIterationsByReviewer, arg.ReviewerID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ReviewIteration
	for rows.Next() {
		var i ReviewIteration
		if err := rows.Scan(
			&i.ID,
			&i.ReviewID,
			&i.IterationNum,
			&i.ReviewerID,
			&i.ReviewerSessionID,
			&i.Decision,
			&i.Summary,
			&i.IssuesJson,
			&i.SuggestionsJson,
			&i.FilesReviewed,
			&i.LinesAnalyzed,
			&i.DurationMs,
			&i.CostUsd,
			&i.StartedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListReviews = `-- name: ListReviews :many
SELECT id, review_id, thread_id, requester_id, pr_number, branch, base_branch, commit_sha, repo_path, review_type, priority, state, created_at, updated_at, completed_at FROM reviews
ORDER BY created_at DESC
LIMIT ?
`

func (q *Queries) ListReviews(ctx context.Context, limit int64) ([]Review, error) {
	rows, err := q.db.QueryContext(ctx, ListReviews, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Review
	for rows.Next() {
		var i Review
		if err := rows.Scan(
			&i.ID,
			&i.ReviewID,
			&i.ThreadID,
			&i.RequesterID,
			&i.PrNumber,
			&i.Branch,
			&i.BaseBranch,
			&i.CommitSha,
			&i.RepoPath,
			&i.ReviewType,
			&i.Priority,
			&i.State,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListReviewsByBranch = `-- name: ListReviewsByBranch :many
SELECT id, review_id, thread_id, requester_id, pr_number, branch, base_branch, commit_sha, repo_path, review_type, priority, state, created_at, updated_at, completed_at FROM reviews
WHERE branch = ?
ORDER BY created_at DESC
LIMIT ?
`

type ListReviewsByBranchParams struct {
	Branch string
	Limit  int64
}

func (q *Queries) ListReviewsByBranch(ctx context.Context, arg ListReviewsByBranchParams) ([]Review, error) {
	rows, err := q.db.QueryContext(ctx, ListReviewsByBranch, arg.Branch, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Review
	for rows.Next() {
		var i Review
		if err := rows.Scan(
			&i.ID,
			&i.ReviewID,
			&i.ThreadID,
			&i.RequesterID,
			&i.PrNumber,
			&i.Branch,
			&i.BaseBranch,
			&i.CommitSha,
			&i.RepoPath,
			&i.ReviewType,
			&i.Priority,
			&i.State,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListReviewsByRequester = `-- name: ListReviewsByRequester :many
SELECT id, review_id, thread_id, requester_id, pr_number, branch, base_branch, commit_sha, repo_path, review_type, priority, state, created_at, updated_at, completed_at FROM reviews
WHERE requester_id = ?
ORDER BY created_at DESC
LIMIT ?
`

type ListReviewsByRequesterParams struct {
	RequesterID int64
	Limit       int64
}

func (q *Queries) ListReviewsByRequester(ctx context.Context, arg ListReviewsByRequesterParams) ([]Review, error) {
	rows, err := q.db.QueryContext(ctx, ListReviewsByRequester, arg.RequesterID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Review
	for rows.Next() {
		var i Review
		if err := rows.Scan(
			&i.ID,
			&i.ReviewID,
			&i.ThreadID,
			&i.RequesterID,
			&i.PrNumber,
			&i.Branch,
			&i.BaseBranch,
			&i.CommitSha,
			&i.RepoPath,
			&i.ReviewType,
			&i.Priority,
			&i.State,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListReviewsByState = `-- name: ListReviewsByState :many
SELECT id, review_id, thread_id, requester_id, pr_number, branch, base_branch, commit_sha, repo_path, review_type, priority, state, created_at, updated_at, completed_at FROM reviews
WHERE state = ?
ORDER BY created_at DESC
LIMIT ?
`

type ListReviewsByStateParams struct {
	State string
	Limit int64
}

func (q *Queries) ListReviewsByState(ctx context.Context, arg ListReviewsByStateParams) ([]Review, error) {
	rows, err := q.db.QueryContext(ctx, ListReviewsByState, arg.State, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Review
	for rows.Next() {
		var i Review
		if err := rows.Scan(
			&i.ID,
			&i.ReviewID,
			&i.ThreadID,
			&i.RequesterID,
			&i.PrNumber,
			&i.Branch,
			&i.BaseBranch,
			&i.CommitSha,
			&i.RepoPath,
			&i.ReviewType,
			&i.Priority,
			&i.State,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ResolveIssue = `-- name: ResolveIssue :exec
UPDATE review_issues
SET status = 'fixed', resolved_at = ?, resolved_in_iteration = ?
WHERE id = ?
`

type ResolveIssueParams struct {
	ResolvedAt          sql.NullInt64
	ResolvedInIteration sql.NullInt64
	ID                  int64
}

func (q *Queries) ResolveIssue(ctx context.Context, arg ResolveIssueParams) error {
	_, err := q.db.ExecContext(ctx, ResolveIssue, arg.ResolvedAt, arg.ResolvedInIteration, arg.ID)
	return err
}

const UpdateReviewCommit = `-- name: UpdateReviewCommit :exec
UPDATE reviews
SET commit_sha = ?, updated_at = ?
WHERE review_id = ?
`

type UpdateReviewCommitParams struct {
	CommitSha string
	UpdatedAt int64
	ReviewID  string
}

func (q *Queries) UpdateReviewCommit(ctx context.Context, arg UpdateReviewCommitParams) error {
	_, err := q.db.ExecContext(ctx, UpdateReviewCommit, arg.CommitSha, arg.UpdatedAt, arg.ReviewID)
	return err
}

const UpdateReviewIssueStatus = `-- name: UpdateReviewIssueStatus :exec
UPDATE review_issues
SET status = ?, resolved_at = ?, resolved_in_iteration = ?
WHERE id = ?
`

type UpdateReviewIssueStatusParams struct {
	Status              string
	ResolvedAt          sql.NullInt64
	ResolvedInIteration sql.NullInt64
	ID                  int64
}

func (q *Queries) UpdateReviewIssueStatus(ctx context.Context, arg UpdateReviewIssueStatusParams) error {
	_, err := q.db.ExecContext(ctx, UpdateReviewIssueStatus, arg.Status, arg.ResolvedAt, arg.ResolvedInIteration, arg.ID)
	return err
}

const UpdateReviewIterationComplete = `-- name: UpdateReviewIterationComplete :exec
UPDATE review_iterations
SET completed_at = ?
WHERE id = ?
`

type UpdateReviewIterationCompleteParams struct {
	CompletedAt sql.NullInt64
	ID          int64
}

func (q *Queries) UpdateReviewIterationComplete(ctx context.Context, arg UpdateReviewIterationCompleteParams) error {
	_, err := q.db.ExecContext(ctx, UpdateReviewIterationComplete, arg.CompletedAt, arg.ID)
	return err
}

const UpdateReviewState = `-- name: UpdateReviewState :exec
UPDATE reviews
SET state = ?, updated_at = ?
WHERE review_id = ?
`

type UpdateReviewStateParams struct {
	State     string
	UpdatedAt int64
	ReviewID  string
}

func (q *Queries) UpdateReviewState(ctx context.Context, arg UpdateReviewStateParams) error {
	_, err := q.db.ExecContext(ctx, UpdateReviewState, arg.State, arg.UpdatedAt, arg.ReviewID)
	return err
}

// replaceSlice replaces a placeholder with multiple ? for IN clauses.
func replaceSlice(query, placeholder string, count int) string {
	if count == 0 {
		return query
	}
	placeholders := make([]byte, 0, count*2-1)
	for i := 0; i < count; i++ {
		if i > 0 {
			placeholders = append(placeholders, ',')
		}
		placeholders = append(placeholders, '?')
	}
	return query[:len(query)-len(placeholder)] + string(placeholders)
}
