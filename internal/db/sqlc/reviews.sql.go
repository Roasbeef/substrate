// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: reviews.sql

package sqlc

import (
	"context"
	"database/sql"
)

const CountOpenIssues = `-- name: CountOpenIssues :one
SELECT COUNT(*) FROM review_issues
WHERE review_id = ? AND status = 'open'
`

func (q *Queries) CountOpenIssues(ctx context.Context, reviewID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, CountOpenIssues, reviewID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CountReviewIssuesByStatus = `-- name: CountReviewIssuesByStatus :one
SELECT COUNT(*) FROM review_issues
WHERE review_id = ? AND status = ?
`

type CountReviewIssuesByStatusParams struct {
	ReviewID string
	Status   string
}

func (q *Queries) CountReviewIssuesByStatus(ctx context.Context, arg CountReviewIssuesByStatusParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, CountReviewIssuesByStatus, arg.ReviewID, arg.Status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CountReviewsByRequester = `-- name: CountReviewsByRequester :one
SELECT COUNT(*) FROM reviews WHERE requester_id = ?
`

func (q *Queries) CountReviewsByRequester(ctx context.Context, requesterID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, CountReviewsByRequester, requesterID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CountReviewsByState = `-- name: CountReviewsByState :one
SELECT COUNT(*) FROM reviews WHERE state = ?
`

func (q *Queries) CountReviewsByState(ctx context.Context, state string) (int64, error) {
	row := q.db.QueryRowContext(ctx, CountReviewsByState, state)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CreateReview = `-- name: CreateReview :one
INSERT INTO reviews (
    review_id, thread_id, requester_id,
    pr_number, branch, base_branch, commit_sha, repo_path, remote_url,
    review_type, priority, state,
    created_at, updated_at
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, review_id, thread_id, requester_id, pr_number, branch, base_branch, commit_sha, repo_path, remote_url, review_type, priority, state, created_at, updated_at, completed_at
`

type CreateReviewParams struct {
	ReviewID    string
	ThreadID    string
	RequesterID int64
	PrNumber    sql.NullInt64
	Branch      string
	BaseBranch  string
	CommitSha   string
	RepoPath    string
	RemoteUrl   sql.NullString
	ReviewType  string
	Priority    string
	State       string
	CreatedAt   int64
	UpdatedAt   int64
}

func (q *Queries) CreateReview(ctx context.Context, arg CreateReviewParams) (Review, error) {
	row := q.db.QueryRowContext(ctx, CreateReview,
		arg.ReviewID,
		arg.ThreadID,
		arg.RequesterID,
		arg.PrNumber,
		arg.Branch,
		arg.BaseBranch,
		arg.CommitSha,
		arg.RepoPath,
		arg.RemoteUrl,
		arg.ReviewType,
		arg.Priority,
		arg.State,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i Review
	err := row.Scan(
		&i.ID,
		&i.ReviewID,
		&i.ThreadID,
		&i.RequesterID,
		&i.PrNumber,
		&i.Branch,
		&i.BaseBranch,
		&i.CommitSha,
		&i.RepoPath,
		&i.RemoteUrl,
		&i.ReviewType,
		&i.Priority,
		&i.State,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
	)
	return i, err
}

const CreateReviewIssue = `-- name: CreateReviewIssue :one
INSERT INTO review_issues (
    review_id, iteration_num,
    issue_type, severity,
    file_path, line_start, line_end,
    title, description, code_snippet, suggestion, claude_md_ref,
    status, created_at
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, review_id, iteration_num, issue_type, severity, file_path, line_start, line_end, title, description, code_snippet, suggestion, claude_md_ref, status, resolved_at, resolved_in_iteration, created_at
`

type CreateReviewIssueParams struct {
	ReviewID     string
	IterationNum int64
	IssueType    string
	Severity     string
	FilePath     string
	LineStart    int64
	LineEnd      sql.NullInt64
	Title        string
	Description  string
	CodeSnippet  sql.NullString
	Suggestion   sql.NullString
	ClaudeMdRef  sql.NullString
	Status       string
	CreatedAt    int64
}

func (q *Queries) CreateReviewIssue(ctx context.Context, arg CreateReviewIssueParams) (ReviewIssue, error) {
	row := q.db.QueryRowContext(ctx, CreateReviewIssue,
		arg.ReviewID,
		arg.IterationNum,
		arg.IssueType,
		arg.Severity,
		arg.FilePath,
		arg.LineStart,
		arg.LineEnd,
		arg.Title,
		arg.Description,
		arg.CodeSnippet,
		arg.Suggestion,
		arg.ClaudeMdRef,
		arg.Status,
		arg.CreatedAt,
	)
	var i ReviewIssue
	err := row.Scan(
		&i.ID,
		&i.ReviewID,
		&i.IterationNum,
		&i.IssueType,
		&i.Severity,
		&i.FilePath,
		&i.LineStart,
		&i.LineEnd,
		&i.Title,
		&i.Description,
		&i.CodeSnippet,
		&i.Suggestion,
		&i.ClaudeMdRef,
		&i.Status,
		&i.ResolvedAt,
		&i.ResolvedInIteration,
		&i.CreatedAt,
	)
	return i, err
}

const CreateReviewIteration = `-- name: CreateReviewIteration :one
INSERT INTO review_iterations (
    review_id, iteration_num, reviewer_id, reviewer_session_id,
    decision, summary, issues_json, suggestions_json,
    files_reviewed, lines_analyzed, duration_ms, cost_usd,
    started_at, completed_at
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, review_id, iteration_num, reviewer_id, reviewer_session_id, decision, summary, issues_json, suggestions_json, files_reviewed, lines_analyzed, duration_ms, cost_usd, started_at, completed_at
`

type CreateReviewIterationParams struct {
	ReviewID          string
	IterationNum      int64
	ReviewerID        string
	ReviewerSessionID sql.NullString
	Decision          string
	Summary           string
	IssuesJson        sql.NullString
	SuggestionsJson   sql.NullString
	FilesReviewed     int64
	LinesAnalyzed     int64
	DurationMs        int64
	CostUsd           float64
	StartedAt         int64
	CompletedAt       sql.NullInt64
}

func (q *Queries) CreateReviewIteration(ctx context.Context, arg CreateReviewIterationParams) (ReviewIteration, error) {
	row := q.db.QueryRowContext(ctx, CreateReviewIteration,
		arg.ReviewID,
		arg.IterationNum,
		arg.ReviewerID,
		arg.ReviewerSessionID,
		arg.Decision,
		arg.Summary,
		arg.IssuesJson,
		arg.SuggestionsJson,
		arg.FilesReviewed,
		arg.LinesAnalyzed,
		arg.DurationMs,
		arg.CostUsd,
		arg.StartedAt,
		arg.CompletedAt,
	)
	var i ReviewIteration
	err := row.Scan(
		&i.ID,
		&i.ReviewID,
		&i.IterationNum,
		&i.ReviewerID,
		&i.ReviewerSessionID,
		&i.Decision,
		&i.Summary,
		&i.IssuesJson,
		&i.SuggestionsJson,
		&i.FilesReviewed,
		&i.LinesAnalyzed,
		&i.DurationMs,
		&i.CostUsd,
		&i.StartedAt,
		&i.CompletedAt,
	)
	return i, err
}

const DeleteReview = `-- name: DeleteReview :exec
DELETE FROM reviews WHERE review_id = ?
`

func (q *Queries) DeleteReview(ctx context.Context, reviewID string) error {
	_, err := q.db.ExecContext(ctx, DeleteReview, reviewID)
	return err
}

const DeleteReviewIssues = `-- name: DeleteReviewIssues :exec
DELETE FROM review_issues WHERE review_id = ?
`

func (q *Queries) DeleteReviewIssues(ctx context.Context, reviewID string) error {
	_, err := q.db.ExecContext(ctx, DeleteReviewIssues, reviewID)
	return err
}

const DeleteReviewIterations = `-- name: DeleteReviewIterations :exec
DELETE FROM review_iterations WHERE review_id = ?
`

func (q *Queries) DeleteReviewIterations(ctx context.Context, reviewID string) error {
	_, err := q.db.ExecContext(ctx, DeleteReviewIterations, reviewID)
	return err
}

const GetLatestIteration = `-- name: GetLatestIteration :one
SELECT id, review_id, iteration_num, reviewer_id, reviewer_session_id, decision, summary, issues_json, suggestions_json, files_reviewed, lines_analyzed, duration_ms, cost_usd, started_at, completed_at FROM review_iterations
WHERE review_id = ?
ORDER BY iteration_num DESC, completed_at DESC
LIMIT 1
`

func (q *Queries) GetLatestIteration(ctx context.Context, reviewID string) (ReviewIteration, error) {
	row := q.db.QueryRowContext(ctx, GetLatestIteration, reviewID)
	var i ReviewIteration
	err := row.Scan(
		&i.ID,
		&i.ReviewID,
		&i.IterationNum,
		&i.ReviewerID,
		&i.ReviewerSessionID,
		&i.Decision,
		&i.Summary,
		&i.IssuesJson,
		&i.SuggestionsJson,
		&i.FilesReviewed,
		&i.LinesAnalyzed,
		&i.DurationMs,
		&i.CostUsd,
		&i.StartedAt,
		&i.CompletedAt,
	)
	return i, err
}

const GetOpenReviewIssues = `-- name: GetOpenReviewIssues :many
SELECT id, review_id, iteration_num, issue_type, severity, file_path, line_start, line_end, title, description, code_snippet, suggestion, claude_md_ref, status, resolved_at, resolved_in_iteration, created_at FROM review_issues
WHERE review_id = ? AND status = 'open'
ORDER BY severity ASC, created_at ASC
`

func (q *Queries) GetOpenReviewIssues(ctx context.Context, reviewID string) ([]ReviewIssue, error) {
	rows, err := q.db.QueryContext(ctx, GetOpenReviewIssues, reviewID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ReviewIssue
	for rows.Next() {
		var i ReviewIssue
		if err := rows.Scan(
			&i.ID,
			&i.ReviewID,
			&i.IterationNum,
			&i.IssueType,
			&i.Severity,
			&i.FilePath,
			&i.LineStart,
			&i.LineEnd,
			&i.Title,
			&i.Description,
			&i.CodeSnippet,
			&i.Suggestion,
			&i.ClaudeMdRef,
			&i.Status,
			&i.ResolvedAt,
			&i.ResolvedInIteration,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetReview = `-- name: GetReview :one
SELECT id, review_id, thread_id, requester_id, pr_number, branch, base_branch, commit_sha, repo_path, remote_url, review_type, priority, state, created_at, updated_at, completed_at FROM reviews WHERE review_id = ?
`

func (q *Queries) GetReview(ctx context.Context, reviewID string) (Review, error) {
	row := q.db.QueryRowContext(ctx, GetReview, reviewID)
	var i Review
	err := row.Scan(
		&i.ID,
		&i.ReviewID,
		&i.ThreadID,
		&i.RequesterID,
		&i.PrNumber,
		&i.Branch,
		&i.BaseBranch,
		&i.CommitSha,
		&i.RepoPath,
		&i.RemoteUrl,
		&i.ReviewType,
		&i.Priority,
		&i.State,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
	)
	return i, err
}

const GetReviewByID = `-- name: GetReviewByID :one
SELECT id, review_id, thread_id, requester_id, pr_number, branch, base_branch, commit_sha, repo_path, remote_url, review_type, priority, state, created_at, updated_at, completed_at FROM reviews WHERE id = ?
`

func (q *Queries) GetReviewByID(ctx context.Context, id int64) (Review, error) {
	row := q.db.QueryRowContext(ctx, GetReviewByID, id)
	var i Review
	err := row.Scan(
		&i.ID,
		&i.ReviewID,
		&i.ThreadID,
		&i.RequesterID,
		&i.PrNumber,
		&i.Branch,
		&i.BaseBranch,
		&i.CommitSha,
		&i.RepoPath,
		&i.RemoteUrl,
		&i.ReviewType,
		&i.Priority,
		&i.State,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
	)
	return i, err
}

const GetReviewIssue = `-- name: GetReviewIssue :one
SELECT id, review_id, iteration_num, issue_type, severity, file_path, line_start, line_end, title, description, code_snippet, suggestion, claude_md_ref, status, resolved_at, resolved_in_iteration, created_at FROM review_issues WHERE id = ?
`

func (q *Queries) GetReviewIssue(ctx context.Context, id int64) (ReviewIssue, error) {
	row := q.db.QueryRowContext(ctx, GetReviewIssue, id)
	var i ReviewIssue
	err := row.Scan(
		&i.ID,
		&i.ReviewID,
		&i.IterationNum,
		&i.IssueType,
		&i.Severity,
		&i.FilePath,
		&i.LineStart,
		&i.LineEnd,
		&i.Title,
		&i.Description,
		&i.CodeSnippet,
		&i.Suggestion,
		&i.ClaudeMdRef,
		&i.Status,
		&i.ResolvedAt,
		&i.ResolvedInIteration,
		&i.CreatedAt,
	)
	return i, err
}

const GetReviewIssues = `-- name: GetReviewIssues :many
SELECT id, review_id, iteration_num, issue_type, severity, file_path, line_start, line_end, title, description, code_snippet, suggestion, claude_md_ref, status, resolved_at, resolved_in_iteration, created_at FROM review_issues
WHERE review_id = ?
ORDER BY severity ASC, created_at ASC
`

func (q *Queries) GetReviewIssues(ctx context.Context, reviewID string) ([]ReviewIssue, error) {
	rows, err := q.db.QueryContext(ctx, GetReviewIssues, reviewID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ReviewIssue
	for rows.Next() {
		var i ReviewIssue
		if err := rows.Scan(
			&i.ID,
			&i.ReviewID,
			&i.IterationNum,
			&i.IssueType,
			&i.Severity,
			&i.FilePath,
			&i.LineStart,
			&i.LineEnd,
			&i.Title,
			&i.Description,
			&i.CodeSnippet,
			&i.Suggestion,
			&i.ClaudeMdRef,
			&i.Status,
			&i.ResolvedAt,
			&i.ResolvedInIteration,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetReviewIssuesByIteration = `-- name: GetReviewIssuesByIteration :many
SELECT id, review_id, iteration_num, issue_type, severity, file_path, line_start, line_end, title, description, code_snippet, suggestion, claude_md_ref, status, resolved_at, resolved_in_iteration, created_at FROM review_issues
WHERE review_id = ? AND iteration_num = ?
ORDER BY severity ASC, created_at ASC
`

type GetReviewIssuesByIterationParams struct {
	ReviewID     string
	IterationNum int64
}

func (q *Queries) GetReviewIssuesByIteration(ctx context.Context, arg GetReviewIssuesByIterationParams) ([]ReviewIssue, error) {
	rows, err := q.db.QueryContext(ctx, GetReviewIssuesByIteration, arg.ReviewID, arg.IterationNum)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ReviewIssue
	for rows.Next() {
		var i ReviewIssue
		if err := rows.Scan(
			&i.ID,
			&i.ReviewID,
			&i.IterationNum,
			&i.IssueType,
			&i.Severity,
			&i.FilePath,
			&i.LineStart,
			&i.LineEnd,
			&i.Title,
			&i.Description,
			&i.CodeSnippet,
			&i.Suggestion,
			&i.ClaudeMdRef,
			&i.Status,
			&i.ResolvedAt,
			&i.ResolvedInIteration,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetReviewIteration = `-- name: GetReviewIteration :one
SELECT id, review_id, iteration_num, reviewer_id, reviewer_session_id, decision, summary, issues_json, suggestions_json, files_reviewed, lines_analyzed, duration_ms, cost_usd, started_at, completed_at FROM review_iterations
WHERE review_id = ? AND iteration_num = ? AND reviewer_id = ?
`

type GetReviewIterationParams struct {
	ReviewID     string
	IterationNum int64
	ReviewerID   string
}

func (q *Queries) GetReviewIteration(ctx context.Context, arg GetReviewIterationParams) (ReviewIteration, error) {
	row := q.db.QueryRowContext(ctx, GetReviewIteration, arg.ReviewID, arg.IterationNum, arg.ReviewerID)
	var i ReviewIteration
	err := row.Scan(
		&i.ID,
		&i.ReviewID,
		&i.IterationNum,
		&i.ReviewerID,
		&i.ReviewerSessionID,
		&i.Decision,
		&i.Summary,
		&i.IssuesJson,
		&i.SuggestionsJson,
		&i.FilesReviewed,
		&i.LinesAnalyzed,
		&i.DurationMs,
		&i.CostUsd,
		&i.StartedAt,
		&i.CompletedAt,
	)
	return i, err
}

const GetReviewIterations = `-- name: GetReviewIterations :many
SELECT id, review_id, iteration_num, reviewer_id, reviewer_session_id, decision, summary, issues_json, suggestions_json, files_reviewed, lines_analyzed, duration_ms, cost_usd, started_at, completed_at FROM review_iterations
WHERE review_id = ?
ORDER BY iteration_num ASC
`

func (q *Queries) GetReviewIterations(ctx context.Context, reviewID string) ([]ReviewIteration, error) {
	rows, err := q.db.QueryContext(ctx, GetReviewIterations, reviewID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ReviewIteration
	for rows.Next() {
		var i ReviewIteration
		if err := rows.Scan(
			&i.ID,
			&i.ReviewID,
			&i.IterationNum,
			&i.ReviewerID,
			&i.ReviewerSessionID,
			&i.Decision,
			&i.Summary,
			&i.IssuesJson,
			&i.SuggestionsJson,
			&i.FilesReviewed,
			&i.LinesAnalyzed,
			&i.DurationMs,
			&i.CostUsd,
			&i.StartedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListActiveReviews = `-- name: ListActiveReviews :many
SELECT id, review_id, thread_id, requester_id, pr_number, branch, base_branch, commit_sha, repo_path, remote_url, review_type, priority, state, created_at, updated_at, completed_at FROM reviews
WHERE state NOT IN ('approved', 'rejected', 'cancelled')
ORDER BY created_at DESC
`

// Returns reviews that are in non-terminal states (for restart recovery).
func (q *Queries) ListActiveReviews(ctx context.Context) ([]Review, error) {
	rows, err := q.db.QueryContext(ctx, ListActiveReviews)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Review
	for rows.Next() {
		var i Review
		if err := rows.Scan(
			&i.ID,
			&i.ReviewID,
			&i.ThreadID,
			&i.RequesterID,
			&i.PrNumber,
			&i.Branch,
			&i.BaseBranch,
			&i.CommitSha,
			&i.RepoPath,
			&i.RemoteUrl,
			&i.ReviewType,
			&i.Priority,
			&i.State,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListReviews = `-- name: ListReviews :many
SELECT id, review_id, thread_id, requester_id, pr_number, branch, base_branch, commit_sha, repo_path, remote_url, review_type, priority, state, created_at, updated_at, completed_at FROM reviews
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type ListReviewsParams struct {
	Limit  int64
	Offset int64
}

func (q *Queries) ListReviews(ctx context.Context, arg ListReviewsParams) ([]Review, error) {
	rows, err := q.db.QueryContext(ctx, ListReviews, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Review
	for rows.Next() {
		var i Review
		if err := rows.Scan(
			&i.ID,
			&i.ReviewID,
			&i.ThreadID,
			&i.RequesterID,
			&i.PrNumber,
			&i.Branch,
			&i.BaseBranch,
			&i.CommitSha,
			&i.RepoPath,
			&i.RemoteUrl,
			&i.ReviewType,
			&i.Priority,
			&i.State,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListReviewsByRequester = `-- name: ListReviewsByRequester :many
SELECT id, review_id, thread_id, requester_id, pr_number, branch, base_branch, commit_sha, repo_path, remote_url, review_type, priority, state, created_at, updated_at, completed_at FROM reviews
WHERE requester_id = ?
ORDER BY created_at DESC
LIMIT ?
`

type ListReviewsByRequesterParams struct {
	RequesterID int64
	Limit       int64
}

func (q *Queries) ListReviewsByRequester(ctx context.Context, arg ListReviewsByRequesterParams) ([]Review, error) {
	rows, err := q.db.QueryContext(ctx, ListReviewsByRequester, arg.RequesterID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Review
	for rows.Next() {
		var i Review
		if err := rows.Scan(
			&i.ID,
			&i.ReviewID,
			&i.ThreadID,
			&i.RequesterID,
			&i.PrNumber,
			&i.Branch,
			&i.BaseBranch,
			&i.CommitSha,
			&i.RepoPath,
			&i.RemoteUrl,
			&i.ReviewType,
			&i.Priority,
			&i.State,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListReviewsByState = `-- name: ListReviewsByState :many
SELECT id, review_id, thread_id, requester_id, pr_number, branch, base_branch, commit_sha, repo_path, remote_url, review_type, priority, state, created_at, updated_at, completed_at FROM reviews
WHERE state = ?
ORDER BY created_at DESC
LIMIT ?
`

type ListReviewsByStateParams struct {
	State string
	Limit int64
}

func (q *Queries) ListReviewsByState(ctx context.Context, arg ListReviewsByStateParams) ([]Review, error) {
	rows, err := q.db.QueryContext(ctx, ListReviewsByState, arg.State, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Review
	for rows.Next() {
		var i Review
		if err := rows.Scan(
			&i.ID,
			&i.ReviewID,
			&i.ThreadID,
			&i.RequesterID,
			&i.PrNumber,
			&i.Branch,
			&i.BaseBranch,
			&i.CommitSha,
			&i.RepoPath,
			&i.RemoteUrl,
			&i.ReviewType,
			&i.Priority,
			&i.State,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ResolveReviewID = `-- name: ResolveReviewID :one
SELECT review_id FROM reviews WHERE review_id LIKE ? || '%' LIMIT 1
`

func (q *Queries) ResolveReviewID(ctx context.Context, dollar_1 sql.NullString) (string, error) {
	row := q.db.QueryRowContext(ctx, ResolveReviewID, dollar_1)
	var review_id string
	err := row.Scan(&review_id)
	return review_id, err
}

const UpdateReviewCompleted = `-- name: UpdateReviewCompleted :exec
UPDATE reviews SET state = ?, updated_at = ?, completed_at = ? WHERE review_id = ?
`

type UpdateReviewCompletedParams struct {
	State       string
	UpdatedAt   int64
	CompletedAt sql.NullInt64
	ReviewID    string
}

func (q *Queries) UpdateReviewCompleted(ctx context.Context, arg UpdateReviewCompletedParams) error {
	_, err := q.db.ExecContext(ctx, UpdateReviewCompleted,
		arg.State,
		arg.UpdatedAt,
		arg.CompletedAt,
		arg.ReviewID,
	)
	return err
}

const UpdateReviewIssueStatus = `-- name: UpdateReviewIssueStatus :exec
UPDATE review_issues
SET status = ?, resolved_at = ?, resolved_in_iteration = ?
WHERE id = ?
`

type UpdateReviewIssueStatusParams struct {
	Status              string
	ResolvedAt          sql.NullInt64
	ResolvedInIteration sql.NullInt64
	ID                  int64
}

func (q *Queries) UpdateReviewIssueStatus(ctx context.Context, arg UpdateReviewIssueStatusParams) error {
	_, err := q.db.ExecContext(ctx, UpdateReviewIssueStatus,
		arg.Status,
		arg.ResolvedAt,
		arg.ResolvedInIteration,
		arg.ID,
	)
	return err
}

const UpdateReviewState = `-- name: UpdateReviewState :exec
UPDATE reviews SET state = ?, updated_at = ? WHERE review_id = ?
`

type UpdateReviewStateParams struct {
	State     string
	UpdatedAt int64
	ReviewID  string
}

func (q *Queries) UpdateReviewState(ctx context.Context, arg UpdateReviewStateParams) error {
	_, err := q.db.ExecContext(ctx, UpdateReviewState, arg.State, arg.UpdatedAt, arg.ReviewID)
	return err
}
