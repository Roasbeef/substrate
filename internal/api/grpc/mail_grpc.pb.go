// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.28.0
// source: mail.proto

package subtraterpc

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	Mail_SendMail_FullMethodName           = "/subtraterpc.Mail/SendMail"
	Mail_FetchInbox_FullMethodName         = "/subtraterpc.Mail/FetchInbox"
	Mail_ReadMessage_FullMethodName        = "/subtraterpc.Mail/ReadMessage"
	Mail_ReadThread_FullMethodName         = "/subtraterpc.Mail/ReadThread"
	Mail_UpdateState_FullMethodName        = "/subtraterpc.Mail/UpdateState"
	Mail_AckMessage_FullMethodName         = "/subtraterpc.Mail/AckMessage"
	Mail_GetStatus_FullMethodName          = "/subtraterpc.Mail/GetStatus"
	Mail_PollChanges_FullMethodName        = "/subtraterpc.Mail/PollChanges"
	Mail_SubscribeInbox_FullMethodName     = "/subtraterpc.Mail/SubscribeInbox"
	Mail_Publish_FullMethodName            = "/subtraterpc.Mail/Publish"
	Mail_Subscribe_FullMethodName          = "/subtraterpc.Mail/Subscribe"
	Mail_Unsubscribe_FullMethodName        = "/subtraterpc.Mail/Unsubscribe"
	Mail_ListTopics_FullMethodName         = "/subtraterpc.Mail/ListTopics"
	Mail_Search_FullMethodName             = "/subtraterpc.Mail/Search"
	Mail_HasUnackedStatusTo_FullMethodName = "/subtraterpc.Mail/HasUnackedStatusTo"
)

// MailClient is the client API for Mail service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Mail is the main RPC service for the Subtrate mail system. It provides
// methods for sending, receiving, and managing messages between agents.
type MailClient interface {
	// SendMail sends a new message to one or more recipients.
	SendMail(ctx context.Context, in *SendMailRequest, opts ...grpc.CallOption) (*SendMailResponse, error)
	// FetchInbox retrieves messages from an agent's inbox.
	FetchInbox(ctx context.Context, in *FetchInboxRequest, opts ...grpc.CallOption) (*FetchInboxResponse, error)
	// ReadMessage retrieves a single message by ID and marks it as read.
	ReadMessage(ctx context.Context, in *ReadMessageRequest, opts ...grpc.CallOption) (*ReadMessageResponse, error)
	// ReadThread retrieves all messages in a thread.
	ReadThread(ctx context.Context, in *ReadThreadRequest, opts ...grpc.CallOption) (*ReadThreadResponse, error)
	// UpdateState changes the state of a message (star, snooze, archive, trash).
	UpdateState(ctx context.Context, in *UpdateStateRequest, opts ...grpc.CallOption) (*UpdateStateResponse, error)
	// AckMessage acknowledges receipt of a message with a deadline.
	AckMessage(ctx context.Context, in *AckMessageRequest, opts ...grpc.CallOption) (*AckMessageResponse, error)
	// GetStatus returns the mail status for an agent.
	GetStatus(ctx context.Context, in *GetStatusRequest, opts ...grpc.CallOption) (*GetStatusResponse, error)
	// PollChanges checks for new messages since given offsets.
	PollChanges(ctx context.Context, in *PollChangesRequest, opts ...grpc.CallOption) (*PollChangesResponse, error)
	// SubscribeInbox creates a stream of new inbox messages.
	SubscribeInbox(ctx context.Context, in *SubscribeInboxRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[InboxMessage], error)
	// Publish sends a message to a pub/sub topic.
	Publish(ctx context.Context, in *PublishRequest, opts ...grpc.CallOption) (*PublishResponse, error)
	// Subscribe subscribes an agent to a topic.
	Subscribe(ctx context.Context, in *SubscribeRequest, opts ...grpc.CallOption) (*SubscribeResponse, error)
	// Unsubscribe removes an agent's subscription to a topic.
	Unsubscribe(ctx context.Context, in *UnsubscribeRequest, opts ...grpc.CallOption) (*UnsubscribeResponse, error)
	// ListTopics lists available topics.
	ListTopics(ctx context.Context, in *ListTopicsRequest, opts ...grpc.CallOption) (*ListTopicsResponse, error)
	// Search performs full-text search across messages.
	Search(ctx context.Context, in *SearchRequest, opts ...grpc.CallOption) (*SearchResponse, error)
	// HasUnackedStatusTo checks if there are unacked status messages from
	// sender to recipient. Used for deduplication in status-update command.
	HasUnackedStatusTo(ctx context.Context, in *HasUnackedStatusToRequest, opts ...grpc.CallOption) (*HasUnackedStatusToResponse, error)
}

type mailClient struct {
	cc grpc.ClientConnInterface
}

func NewMailClient(cc grpc.ClientConnInterface) MailClient {
	return &mailClient{cc}
}

func (c *mailClient) SendMail(ctx context.Context, in *SendMailRequest, opts ...grpc.CallOption) (*SendMailResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SendMailResponse)
	err := c.cc.Invoke(ctx, Mail_SendMail_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mailClient) FetchInbox(ctx context.Context, in *FetchInboxRequest, opts ...grpc.CallOption) (*FetchInboxResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FetchInboxResponse)
	err := c.cc.Invoke(ctx, Mail_FetchInbox_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mailClient) ReadMessage(ctx context.Context, in *ReadMessageRequest, opts ...grpc.CallOption) (*ReadMessageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReadMessageResponse)
	err := c.cc.Invoke(ctx, Mail_ReadMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mailClient) ReadThread(ctx context.Context, in *ReadThreadRequest, opts ...grpc.CallOption) (*ReadThreadResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReadThreadResponse)
	err := c.cc.Invoke(ctx, Mail_ReadThread_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mailClient) UpdateState(ctx context.Context, in *UpdateStateRequest, opts ...grpc.CallOption) (*UpdateStateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateStateResponse)
	err := c.cc.Invoke(ctx, Mail_UpdateState_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mailClient) AckMessage(ctx context.Context, in *AckMessageRequest, opts ...grpc.CallOption) (*AckMessageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AckMessageResponse)
	err := c.cc.Invoke(ctx, Mail_AckMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mailClient) GetStatus(ctx context.Context, in *GetStatusRequest, opts ...grpc.CallOption) (*GetStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetStatusResponse)
	err := c.cc.Invoke(ctx, Mail_GetStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mailClient) PollChanges(ctx context.Context, in *PollChangesRequest, opts ...grpc.CallOption) (*PollChangesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PollChangesResponse)
	err := c.cc.Invoke(ctx, Mail_PollChanges_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mailClient) SubscribeInbox(ctx context.Context, in *SubscribeInboxRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[InboxMessage], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Mail_ServiceDesc.Streams[0], Mail_SubscribeInbox_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[SubscribeInboxRequest, InboxMessage]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Mail_SubscribeInboxClient = grpc.ServerStreamingClient[InboxMessage]

func (c *mailClient) Publish(ctx context.Context, in *PublishRequest, opts ...grpc.CallOption) (*PublishResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PublishResponse)
	err := c.cc.Invoke(ctx, Mail_Publish_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mailClient) Subscribe(ctx context.Context, in *SubscribeRequest, opts ...grpc.CallOption) (*SubscribeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SubscribeResponse)
	err := c.cc.Invoke(ctx, Mail_Subscribe_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mailClient) Unsubscribe(ctx context.Context, in *UnsubscribeRequest, opts ...grpc.CallOption) (*UnsubscribeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UnsubscribeResponse)
	err := c.cc.Invoke(ctx, Mail_Unsubscribe_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mailClient) ListTopics(ctx context.Context, in *ListTopicsRequest, opts ...grpc.CallOption) (*ListTopicsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListTopicsResponse)
	err := c.cc.Invoke(ctx, Mail_ListTopics_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mailClient) Search(ctx context.Context, in *SearchRequest, opts ...grpc.CallOption) (*SearchResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SearchResponse)
	err := c.cc.Invoke(ctx, Mail_Search_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mailClient) HasUnackedStatusTo(ctx context.Context, in *HasUnackedStatusToRequest, opts ...grpc.CallOption) (*HasUnackedStatusToResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HasUnackedStatusToResponse)
	err := c.cc.Invoke(ctx, Mail_HasUnackedStatusTo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MailServer is the server API for Mail service.
// All implementations must embed UnimplementedMailServer
// for forward compatibility.
//
// Mail is the main RPC service for the Subtrate mail system. It provides
// methods for sending, receiving, and managing messages between agents.
type MailServer interface {
	// SendMail sends a new message to one or more recipients.
	SendMail(context.Context, *SendMailRequest) (*SendMailResponse, error)
	// FetchInbox retrieves messages from an agent's inbox.
	FetchInbox(context.Context, *FetchInboxRequest) (*FetchInboxResponse, error)
	// ReadMessage retrieves a single message by ID and marks it as read.
	ReadMessage(context.Context, *ReadMessageRequest) (*ReadMessageResponse, error)
	// ReadThread retrieves all messages in a thread.
	ReadThread(context.Context, *ReadThreadRequest) (*ReadThreadResponse, error)
	// UpdateState changes the state of a message (star, snooze, archive, trash).
	UpdateState(context.Context, *UpdateStateRequest) (*UpdateStateResponse, error)
	// AckMessage acknowledges receipt of a message with a deadline.
	AckMessage(context.Context, *AckMessageRequest) (*AckMessageResponse, error)
	// GetStatus returns the mail status for an agent.
	GetStatus(context.Context, *GetStatusRequest) (*GetStatusResponse, error)
	// PollChanges checks for new messages since given offsets.
	PollChanges(context.Context, *PollChangesRequest) (*PollChangesResponse, error)
	// SubscribeInbox creates a stream of new inbox messages.
	SubscribeInbox(*SubscribeInboxRequest, grpc.ServerStreamingServer[InboxMessage]) error
	// Publish sends a message to a pub/sub topic.
	Publish(context.Context, *PublishRequest) (*PublishResponse, error)
	// Subscribe subscribes an agent to a topic.
	Subscribe(context.Context, *SubscribeRequest) (*SubscribeResponse, error)
	// Unsubscribe removes an agent's subscription to a topic.
	Unsubscribe(context.Context, *UnsubscribeRequest) (*UnsubscribeResponse, error)
	// ListTopics lists available topics.
	ListTopics(context.Context, *ListTopicsRequest) (*ListTopicsResponse, error)
	// Search performs full-text search across messages.
	Search(context.Context, *SearchRequest) (*SearchResponse, error)
	// HasUnackedStatusTo checks if there are unacked status messages from
	// sender to recipient. Used for deduplication in status-update command.
	HasUnackedStatusTo(context.Context, *HasUnackedStatusToRequest) (*HasUnackedStatusToResponse, error)
	mustEmbedUnimplementedMailServer()
}

// UnimplementedMailServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMailServer struct{}

func (UnimplementedMailServer) SendMail(context.Context, *SendMailRequest) (*SendMailResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendMail not implemented")
}
func (UnimplementedMailServer) FetchInbox(context.Context, *FetchInboxRequest) (*FetchInboxResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FetchInbox not implemented")
}
func (UnimplementedMailServer) ReadMessage(context.Context, *ReadMessageRequest) (*ReadMessageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReadMessage not implemented")
}
func (UnimplementedMailServer) ReadThread(context.Context, *ReadThreadRequest) (*ReadThreadResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReadThread not implemented")
}
func (UnimplementedMailServer) UpdateState(context.Context, *UpdateStateRequest) (*UpdateStateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateState not implemented")
}
func (UnimplementedMailServer) AckMessage(context.Context, *AckMessageRequest) (*AckMessageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AckMessage not implemented")
}
func (UnimplementedMailServer) GetStatus(context.Context, *GetStatusRequest) (*GetStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetStatus not implemented")
}
func (UnimplementedMailServer) PollChanges(context.Context, *PollChangesRequest) (*PollChangesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PollChanges not implemented")
}
func (UnimplementedMailServer) SubscribeInbox(*SubscribeInboxRequest, grpc.ServerStreamingServer[InboxMessage]) error {
	return status.Errorf(codes.Unimplemented, "method SubscribeInbox not implemented")
}
func (UnimplementedMailServer) Publish(context.Context, *PublishRequest) (*PublishResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Publish not implemented")
}
func (UnimplementedMailServer) Subscribe(context.Context, *SubscribeRequest) (*SubscribeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Subscribe not implemented")
}
func (UnimplementedMailServer) Unsubscribe(context.Context, *UnsubscribeRequest) (*UnsubscribeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Unsubscribe not implemented")
}
func (UnimplementedMailServer) ListTopics(context.Context, *ListTopicsRequest) (*ListTopicsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListTopics not implemented")
}
func (UnimplementedMailServer) Search(context.Context, *SearchRequest) (*SearchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Search not implemented")
}
func (UnimplementedMailServer) HasUnackedStatusTo(context.Context, *HasUnackedStatusToRequest) (*HasUnackedStatusToResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HasUnackedStatusTo not implemented")
}
func (UnimplementedMailServer) mustEmbedUnimplementedMailServer() {}
func (UnimplementedMailServer) testEmbeddedByValue()              {}

// UnsafeMailServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MailServer will
// result in compilation errors.
type UnsafeMailServer interface {
	mustEmbedUnimplementedMailServer()
}

func RegisterMailServer(s grpc.ServiceRegistrar, srv MailServer) {
	// If the following call pancis, it indicates UnimplementedMailServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Mail_ServiceDesc, srv)
}

func _Mail_SendMail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendMailRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MailServer).SendMail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mail_SendMail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MailServer).SendMail(ctx, req.(*SendMailRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mail_FetchInbox_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FetchInboxRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MailServer).FetchInbox(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mail_FetchInbox_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MailServer).FetchInbox(ctx, req.(*FetchInboxRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mail_ReadMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReadMessageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MailServer).ReadMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mail_ReadMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MailServer).ReadMessage(ctx, req.(*ReadMessageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mail_ReadThread_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReadThreadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MailServer).ReadThread(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mail_ReadThread_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MailServer).ReadThread(ctx, req.(*ReadThreadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mail_UpdateState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateStateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MailServer).UpdateState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mail_UpdateState_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MailServer).UpdateState(ctx, req.(*UpdateStateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mail_AckMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AckMessageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MailServer).AckMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mail_AckMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MailServer).AckMessage(ctx, req.(*AckMessageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mail_GetStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MailServer).GetStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mail_GetStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MailServer).GetStatus(ctx, req.(*GetStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mail_PollChanges_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PollChangesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MailServer).PollChanges(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mail_PollChanges_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MailServer).PollChanges(ctx, req.(*PollChangesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mail_SubscribeInbox_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeInboxRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(MailServer).SubscribeInbox(m, &grpc.GenericServerStream[SubscribeInboxRequest, InboxMessage]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Mail_SubscribeInboxServer = grpc.ServerStreamingServer[InboxMessage]

func _Mail_Publish_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PublishRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MailServer).Publish(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mail_Publish_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MailServer).Publish(ctx, req.(*PublishRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mail_Subscribe_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubscribeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MailServer).Subscribe(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mail_Subscribe_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MailServer).Subscribe(ctx, req.(*SubscribeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mail_Unsubscribe_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnsubscribeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MailServer).Unsubscribe(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mail_Unsubscribe_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MailServer).Unsubscribe(ctx, req.(*UnsubscribeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mail_ListTopics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListTopicsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MailServer).ListTopics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mail_ListTopics_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MailServer).ListTopics(ctx, req.(*ListTopicsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mail_Search_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MailServer).Search(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mail_Search_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MailServer).Search(ctx, req.(*SearchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mail_HasUnackedStatusTo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HasUnackedStatusToRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MailServer).HasUnackedStatusTo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mail_HasUnackedStatusTo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MailServer).HasUnackedStatusTo(ctx, req.(*HasUnackedStatusToRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Mail_ServiceDesc is the grpc.ServiceDesc for Mail service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Mail_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "subtraterpc.Mail",
	HandlerType: (*MailServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SendMail",
			Handler:    _Mail_SendMail_Handler,
		},
		{
			MethodName: "FetchInbox",
			Handler:    _Mail_FetchInbox_Handler,
		},
		{
			MethodName: "ReadMessage",
			Handler:    _Mail_ReadMessage_Handler,
		},
		{
			MethodName: "ReadThread",
			Handler:    _Mail_ReadThread_Handler,
		},
		{
			MethodName: "UpdateState",
			Handler:    _Mail_UpdateState_Handler,
		},
		{
			MethodName: "AckMessage",
			Handler:    _Mail_AckMessage_Handler,
		},
		{
			MethodName: "GetStatus",
			Handler:    _Mail_GetStatus_Handler,
		},
		{
			MethodName: "PollChanges",
			Handler:    _Mail_PollChanges_Handler,
		},
		{
			MethodName: "Publish",
			Handler:    _Mail_Publish_Handler,
		},
		{
			MethodName: "Subscribe",
			Handler:    _Mail_Subscribe_Handler,
		},
		{
			MethodName: "Unsubscribe",
			Handler:    _Mail_Unsubscribe_Handler,
		},
		{
			MethodName: "ListTopics",
			Handler:    _Mail_ListTopics_Handler,
		},
		{
			MethodName: "Search",
			Handler:    _Mail_Search_Handler,
		},
		{
			MethodName: "HasUnackedStatusTo",
			Handler:    _Mail_HasUnackedStatusTo_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SubscribeInbox",
			Handler:       _Mail_SubscribeInbox_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "mail.proto",
}

const (
	Agent_RegisterAgent_FullMethodName  = "/subtraterpc.Agent/RegisterAgent"
	Agent_GetAgent_FullMethodName       = "/subtraterpc.Agent/GetAgent"
	Agent_ListAgents_FullMethodName     = "/subtraterpc.Agent/ListAgents"
	Agent_DeleteAgent_FullMethodName    = "/subtraterpc.Agent/DeleteAgent"
	Agent_EnsureIdentity_FullMethodName = "/subtraterpc.Agent/EnsureIdentity"
	Agent_SaveIdentity_FullMethodName   = "/subtraterpc.Agent/SaveIdentity"
)

// AgentClient is the client API for Agent service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Agent is the RPC service for managing agent identities.
type AgentClient interface {
	// RegisterAgent creates a new agent with the given name.
	RegisterAgent(ctx context.Context, in *RegisterAgentRequest, opts ...grpc.CallOption) (*RegisterAgentResponse, error)
	// GetAgent retrieves an agent by ID or name.
	GetAgent(ctx context.Context, in *GetAgentRequest, opts ...grpc.CallOption) (*GetAgentResponse, error)
	// ListAgents lists all registered agents.
	ListAgents(ctx context.Context, in *ListAgentsRequest, opts ...grpc.CallOption) (*ListAgentsResponse, error)
	// DeleteAgent removes an agent by ID.
	DeleteAgent(ctx context.Context, in *DeleteAgentRequest, opts ...grpc.CallOption) (*DeleteAgentResponse, error)
	// EnsureIdentity creates or retrieves an agent identity for a session.
	EnsureIdentity(ctx context.Context, in *EnsureIdentityRequest, opts ...grpc.CallOption) (*EnsureIdentityResponse, error)
	// SaveIdentity persists an agent's current state.
	SaveIdentity(ctx context.Context, in *SaveIdentityRequest, opts ...grpc.CallOption) (*SaveIdentityResponse, error)
}

type agentClient struct {
	cc grpc.ClientConnInterface
}

func NewAgentClient(cc grpc.ClientConnInterface) AgentClient {
	return &agentClient{cc}
}

func (c *agentClient) RegisterAgent(ctx context.Context, in *RegisterAgentRequest, opts ...grpc.CallOption) (*RegisterAgentResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RegisterAgentResponse)
	err := c.cc.Invoke(ctx, Agent_RegisterAgent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentClient) GetAgent(ctx context.Context, in *GetAgentRequest, opts ...grpc.CallOption) (*GetAgentResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetAgentResponse)
	err := c.cc.Invoke(ctx, Agent_GetAgent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentClient) ListAgents(ctx context.Context, in *ListAgentsRequest, opts ...grpc.CallOption) (*ListAgentsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListAgentsResponse)
	err := c.cc.Invoke(ctx, Agent_ListAgents_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentClient) DeleteAgent(ctx context.Context, in *DeleteAgentRequest, opts ...grpc.CallOption) (*DeleteAgentResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteAgentResponse)
	err := c.cc.Invoke(ctx, Agent_DeleteAgent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentClient) EnsureIdentity(ctx context.Context, in *EnsureIdentityRequest, opts ...grpc.CallOption) (*EnsureIdentityResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EnsureIdentityResponse)
	err := c.cc.Invoke(ctx, Agent_EnsureIdentity_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentClient) SaveIdentity(ctx context.Context, in *SaveIdentityRequest, opts ...grpc.CallOption) (*SaveIdentityResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SaveIdentityResponse)
	err := c.cc.Invoke(ctx, Agent_SaveIdentity_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AgentServer is the server API for Agent service.
// All implementations must embed UnimplementedAgentServer
// for forward compatibility.
//
// Agent is the RPC service for managing agent identities.
type AgentServer interface {
	// RegisterAgent creates a new agent with the given name.
	RegisterAgent(context.Context, *RegisterAgentRequest) (*RegisterAgentResponse, error)
	// GetAgent retrieves an agent by ID or name.
	GetAgent(context.Context, *GetAgentRequest) (*GetAgentResponse, error)
	// ListAgents lists all registered agents.
	ListAgents(context.Context, *ListAgentsRequest) (*ListAgentsResponse, error)
	// DeleteAgent removes an agent by ID.
	DeleteAgent(context.Context, *DeleteAgentRequest) (*DeleteAgentResponse, error)
	// EnsureIdentity creates or retrieves an agent identity for a session.
	EnsureIdentity(context.Context, *EnsureIdentityRequest) (*EnsureIdentityResponse, error)
	// SaveIdentity persists an agent's current state.
	SaveIdentity(context.Context, *SaveIdentityRequest) (*SaveIdentityResponse, error)
	mustEmbedUnimplementedAgentServer()
}

// UnimplementedAgentServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedAgentServer struct{}

func (UnimplementedAgentServer) RegisterAgent(context.Context, *RegisterAgentRequest) (*RegisterAgentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterAgent not implemented")
}
func (UnimplementedAgentServer) GetAgent(context.Context, *GetAgentRequest) (*GetAgentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAgent not implemented")
}
func (UnimplementedAgentServer) ListAgents(context.Context, *ListAgentsRequest) (*ListAgentsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListAgents not implemented")
}
func (UnimplementedAgentServer) DeleteAgent(context.Context, *DeleteAgentRequest) (*DeleteAgentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteAgent not implemented")
}
func (UnimplementedAgentServer) EnsureIdentity(context.Context, *EnsureIdentityRequest) (*EnsureIdentityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EnsureIdentity not implemented")
}
func (UnimplementedAgentServer) SaveIdentity(context.Context, *SaveIdentityRequest) (*SaveIdentityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SaveIdentity not implemented")
}
func (UnimplementedAgentServer) mustEmbedUnimplementedAgentServer() {}
func (UnimplementedAgentServer) testEmbeddedByValue()               {}

// UnsafeAgentServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AgentServer will
// result in compilation errors.
type UnsafeAgentServer interface {
	mustEmbedUnimplementedAgentServer()
}

func RegisterAgentServer(s grpc.ServiceRegistrar, srv AgentServer) {
	// If the following call pancis, it indicates UnimplementedAgentServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Agent_ServiceDesc, srv)
}

func _Agent_RegisterAgent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterAgentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServer).RegisterAgent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Agent_RegisterAgent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServer).RegisterAgent(ctx, req.(*RegisterAgentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Agent_GetAgent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAgentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServer).GetAgent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Agent_GetAgent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServer).GetAgent(ctx, req.(*GetAgentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Agent_ListAgents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListAgentsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServer).ListAgents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Agent_ListAgents_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServer).ListAgents(ctx, req.(*ListAgentsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Agent_DeleteAgent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteAgentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServer).DeleteAgent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Agent_DeleteAgent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServer).DeleteAgent(ctx, req.(*DeleteAgentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Agent_EnsureIdentity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EnsureIdentityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServer).EnsureIdentity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Agent_EnsureIdentity_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServer).EnsureIdentity(ctx, req.(*EnsureIdentityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Agent_SaveIdentity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SaveIdentityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServer).SaveIdentity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Agent_SaveIdentity_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServer).SaveIdentity(ctx, req.(*SaveIdentityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Agent_ServiceDesc is the grpc.ServiceDesc for Agent service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Agent_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "subtraterpc.Agent",
	HandlerType: (*AgentServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RegisterAgent",
			Handler:    _Agent_RegisterAgent_Handler,
		},
		{
			MethodName: "GetAgent",
			Handler:    _Agent_GetAgent_Handler,
		},
		{
			MethodName: "ListAgents",
			Handler:    _Agent_ListAgents_Handler,
		},
		{
			MethodName: "DeleteAgent",
			Handler:    _Agent_DeleteAgent_Handler,
		},
		{
			MethodName: "EnsureIdentity",
			Handler:    _Agent_EnsureIdentity_Handler,
		},
		{
			MethodName: "SaveIdentity",
			Handler:    _Agent_SaveIdentity_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "mail.proto",
}
