// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.28.0
// source: mail.proto

package subtraterpc

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	Mail_SendMail_FullMethodName               = "/subtraterpc.Mail/SendMail"
	Mail_FetchInbox_FullMethodName             = "/subtraterpc.Mail/FetchInbox"
	Mail_ReadMessage_FullMethodName            = "/subtraterpc.Mail/ReadMessage"
	Mail_ReadThread_FullMethodName             = "/subtraterpc.Mail/ReadThread"
	Mail_UpdateState_FullMethodName            = "/subtraterpc.Mail/UpdateState"
	Mail_AckMessage_FullMethodName             = "/subtraterpc.Mail/AckMessage"
	Mail_GetStatus_FullMethodName              = "/subtraterpc.Mail/GetStatus"
	Mail_PollChanges_FullMethodName            = "/subtraterpc.Mail/PollChanges"
	Mail_SubscribeInbox_FullMethodName         = "/subtraterpc.Mail/SubscribeInbox"
	Mail_Publish_FullMethodName                = "/subtraterpc.Mail/Publish"
	Mail_Subscribe_FullMethodName              = "/subtraterpc.Mail/Subscribe"
	Mail_Unsubscribe_FullMethodName            = "/subtraterpc.Mail/Unsubscribe"
	Mail_ListTopics_FullMethodName             = "/subtraterpc.Mail/ListTopics"
	Mail_Search_FullMethodName                 = "/subtraterpc.Mail/Search"
	Mail_HasUnackedStatusTo_FullMethodName     = "/subtraterpc.Mail/HasUnackedStatusTo"
	Mail_ReplyToThread_FullMethodName          = "/subtraterpc.Mail/ReplyToThread"
	Mail_ArchiveThread_FullMethodName          = "/subtraterpc.Mail/ArchiveThread"
	Mail_DeleteThread_FullMethodName           = "/subtraterpc.Mail/DeleteThread"
	Mail_MarkThreadUnread_FullMethodName       = "/subtraterpc.Mail/MarkThreadUnread"
	Mail_GetTopic_FullMethodName               = "/subtraterpc.Mail/GetTopic"
	Mail_AutocompleteRecipients_FullMethodName = "/subtraterpc.Mail/AutocompleteRecipients"
	Mail_DeleteMessage_FullMethodName          = "/subtraterpc.Mail/DeleteMessage"
)

// MailClient is the client API for Mail service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Mail is the main RPC service for the Subtrate mail system. It provides
// methods for sending, receiving, and managing messages between agents.
type MailClient interface {
	// SendMail sends a new message to one or more recipients.
	SendMail(ctx context.Context, in *SendMailRequest, opts ...grpc.CallOption) (*SendMailResponse, error)
	// FetchInbox retrieves messages from an agent's inbox.
	FetchInbox(ctx context.Context, in *FetchInboxRequest, opts ...grpc.CallOption) (*FetchInboxResponse, error)
	// ReadMessage retrieves a single message by ID and marks it as read.
	ReadMessage(ctx context.Context, in *ReadMessageRequest, opts ...grpc.CallOption) (*ReadMessageResponse, error)
	// ReadThread retrieves all messages in a thread.
	ReadThread(ctx context.Context, in *ReadThreadRequest, opts ...grpc.CallOption) (*ReadThreadResponse, error)
	// UpdateState changes the state of a message (star, snooze, archive, trash).
	UpdateState(ctx context.Context, in *UpdateStateRequest, opts ...grpc.CallOption) (*UpdateStateResponse, error)
	// AckMessage acknowledges receipt of a message with a deadline.
	AckMessage(ctx context.Context, in *AckMessageRequest, opts ...grpc.CallOption) (*AckMessageResponse, error)
	// GetStatus returns the mail status for an agent.
	GetStatus(ctx context.Context, in *GetStatusRequest, opts ...grpc.CallOption) (*GetStatusResponse, error)
	// PollChanges checks for new messages since given offsets.
	PollChanges(ctx context.Context, in *PollChangesRequest, opts ...grpc.CallOption) (*PollChangesResponse, error)
	// SubscribeInbox creates a stream of new inbox messages.
	SubscribeInbox(ctx context.Context, in *SubscribeInboxRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[InboxMessage], error)
	// Publish sends a message to a pub/sub topic.
	Publish(ctx context.Context, in *PublishRequest, opts ...grpc.CallOption) (*PublishResponse, error)
	// Subscribe subscribes an agent to a topic.
	Subscribe(ctx context.Context, in *SubscribeRequest, opts ...grpc.CallOption) (*SubscribeResponse, error)
	// Unsubscribe removes an agent's subscription to a topic.
	Unsubscribe(ctx context.Context, in *UnsubscribeRequest, opts ...grpc.CallOption) (*UnsubscribeResponse, error)
	// ListTopics lists available topics.
	ListTopics(ctx context.Context, in *ListTopicsRequest, opts ...grpc.CallOption) (*ListTopicsResponse, error)
	// Search performs full-text search across messages.
	Search(ctx context.Context, in *SearchRequest, opts ...grpc.CallOption) (*SearchResponse, error)
	// HasUnackedStatusTo checks if there are unacked status messages from
	// sender to recipient. Used for deduplication in status-update command.
	HasUnackedStatusTo(ctx context.Context, in *HasUnackedStatusToRequest, opts ...grpc.CallOption) (*HasUnackedStatusToResponse, error)
	// ReplyToThread sends a reply message to an existing thread.
	ReplyToThread(ctx context.Context, in *ReplyToThreadRequest, opts ...grpc.CallOption) (*ReplyToThreadResponse, error)
	// ArchiveThread archives all messages in a thread.
	ArchiveThread(ctx context.Context, in *ArchiveThreadRequest, opts ...grpc.CallOption) (*ArchiveThreadResponse, error)
	// DeleteThread deletes all messages in a thread.
	DeleteThread(ctx context.Context, in *DeleteThreadRequest, opts ...grpc.CallOption) (*DeleteThreadResponse, error)
	// MarkThreadUnread marks a thread as unread.
	MarkThreadUnread(ctx context.Context, in *MarkThreadUnreadRequest, opts ...grpc.CallOption) (*MarkThreadUnreadResponse, error)
	// GetTopic retrieves a single topic by ID.
	GetTopic(ctx context.Context, in *GetTopicRequest, opts ...grpc.CallOption) (*GetTopicResponse, error)
	// AutocompleteRecipients returns matching agents for autocomplete.
	AutocompleteRecipients(ctx context.Context, in *AutocompleteRecipientsRequest, opts ...grpc.CallOption) (*AutocompleteRecipientsResponse, error)
	// DeleteMessage marks a message as deleted/trash.
	DeleteMessage(ctx context.Context, in *DeleteMessageRequest, opts ...grpc.CallOption) (*DeleteMessageResponse, error)
}

type mailClient struct {
	cc grpc.ClientConnInterface
}

func NewMailClient(cc grpc.ClientConnInterface) MailClient {
	return &mailClient{cc}
}

func (c *mailClient) SendMail(ctx context.Context, in *SendMailRequest, opts ...grpc.CallOption) (*SendMailResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SendMailResponse)
	err := c.cc.Invoke(ctx, Mail_SendMail_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mailClient) FetchInbox(ctx context.Context, in *FetchInboxRequest, opts ...grpc.CallOption) (*FetchInboxResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FetchInboxResponse)
	err := c.cc.Invoke(ctx, Mail_FetchInbox_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mailClient) ReadMessage(ctx context.Context, in *ReadMessageRequest, opts ...grpc.CallOption) (*ReadMessageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReadMessageResponse)
	err := c.cc.Invoke(ctx, Mail_ReadMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mailClient) ReadThread(ctx context.Context, in *ReadThreadRequest, opts ...grpc.CallOption) (*ReadThreadResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReadThreadResponse)
	err := c.cc.Invoke(ctx, Mail_ReadThread_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mailClient) UpdateState(ctx context.Context, in *UpdateStateRequest, opts ...grpc.CallOption) (*UpdateStateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateStateResponse)
	err := c.cc.Invoke(ctx, Mail_UpdateState_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mailClient) AckMessage(ctx context.Context, in *AckMessageRequest, opts ...grpc.CallOption) (*AckMessageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AckMessageResponse)
	err := c.cc.Invoke(ctx, Mail_AckMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mailClient) GetStatus(ctx context.Context, in *GetStatusRequest, opts ...grpc.CallOption) (*GetStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetStatusResponse)
	err := c.cc.Invoke(ctx, Mail_GetStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mailClient) PollChanges(ctx context.Context, in *PollChangesRequest, opts ...grpc.CallOption) (*PollChangesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PollChangesResponse)
	err := c.cc.Invoke(ctx, Mail_PollChanges_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mailClient) SubscribeInbox(ctx context.Context, in *SubscribeInboxRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[InboxMessage], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Mail_ServiceDesc.Streams[0], Mail_SubscribeInbox_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[SubscribeInboxRequest, InboxMessage]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Mail_SubscribeInboxClient = grpc.ServerStreamingClient[InboxMessage]

func (c *mailClient) Publish(ctx context.Context, in *PublishRequest, opts ...grpc.CallOption) (*PublishResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PublishResponse)
	err := c.cc.Invoke(ctx, Mail_Publish_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mailClient) Subscribe(ctx context.Context, in *SubscribeRequest, opts ...grpc.CallOption) (*SubscribeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SubscribeResponse)
	err := c.cc.Invoke(ctx, Mail_Subscribe_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mailClient) Unsubscribe(ctx context.Context, in *UnsubscribeRequest, opts ...grpc.CallOption) (*UnsubscribeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UnsubscribeResponse)
	err := c.cc.Invoke(ctx, Mail_Unsubscribe_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mailClient) ListTopics(ctx context.Context, in *ListTopicsRequest, opts ...grpc.CallOption) (*ListTopicsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListTopicsResponse)
	err := c.cc.Invoke(ctx, Mail_ListTopics_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mailClient) Search(ctx context.Context, in *SearchRequest, opts ...grpc.CallOption) (*SearchResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SearchResponse)
	err := c.cc.Invoke(ctx, Mail_Search_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mailClient) HasUnackedStatusTo(ctx context.Context, in *HasUnackedStatusToRequest, opts ...grpc.CallOption) (*HasUnackedStatusToResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HasUnackedStatusToResponse)
	err := c.cc.Invoke(ctx, Mail_HasUnackedStatusTo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mailClient) ReplyToThread(ctx context.Context, in *ReplyToThreadRequest, opts ...grpc.CallOption) (*ReplyToThreadResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReplyToThreadResponse)
	err := c.cc.Invoke(ctx, Mail_ReplyToThread_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mailClient) ArchiveThread(ctx context.Context, in *ArchiveThreadRequest, opts ...grpc.CallOption) (*ArchiveThreadResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ArchiveThreadResponse)
	err := c.cc.Invoke(ctx, Mail_ArchiveThread_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mailClient) DeleteThread(ctx context.Context, in *DeleteThreadRequest, opts ...grpc.CallOption) (*DeleteThreadResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteThreadResponse)
	err := c.cc.Invoke(ctx, Mail_DeleteThread_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mailClient) MarkThreadUnread(ctx context.Context, in *MarkThreadUnreadRequest, opts ...grpc.CallOption) (*MarkThreadUnreadResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MarkThreadUnreadResponse)
	err := c.cc.Invoke(ctx, Mail_MarkThreadUnread_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mailClient) GetTopic(ctx context.Context, in *GetTopicRequest, opts ...grpc.CallOption) (*GetTopicResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTopicResponse)
	err := c.cc.Invoke(ctx, Mail_GetTopic_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mailClient) AutocompleteRecipients(ctx context.Context, in *AutocompleteRecipientsRequest, opts ...grpc.CallOption) (*AutocompleteRecipientsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AutocompleteRecipientsResponse)
	err := c.cc.Invoke(ctx, Mail_AutocompleteRecipients_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mailClient) DeleteMessage(ctx context.Context, in *DeleteMessageRequest, opts ...grpc.CallOption) (*DeleteMessageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteMessageResponse)
	err := c.cc.Invoke(ctx, Mail_DeleteMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MailServer is the server API for Mail service.
// All implementations must embed UnimplementedMailServer
// for forward compatibility.
//
// Mail is the main RPC service for the Subtrate mail system. It provides
// methods for sending, receiving, and managing messages between agents.
type MailServer interface {
	// SendMail sends a new message to one or more recipients.
	SendMail(context.Context, *SendMailRequest) (*SendMailResponse, error)
	// FetchInbox retrieves messages from an agent's inbox.
	FetchInbox(context.Context, *FetchInboxRequest) (*FetchInboxResponse, error)
	// ReadMessage retrieves a single message by ID and marks it as read.
	ReadMessage(context.Context, *ReadMessageRequest) (*ReadMessageResponse, error)
	// ReadThread retrieves all messages in a thread.
	ReadThread(context.Context, *ReadThreadRequest) (*ReadThreadResponse, error)
	// UpdateState changes the state of a message (star, snooze, archive, trash).
	UpdateState(context.Context, *UpdateStateRequest) (*UpdateStateResponse, error)
	// AckMessage acknowledges receipt of a message with a deadline.
	AckMessage(context.Context, *AckMessageRequest) (*AckMessageResponse, error)
	// GetStatus returns the mail status for an agent.
	GetStatus(context.Context, *GetStatusRequest) (*GetStatusResponse, error)
	// PollChanges checks for new messages since given offsets.
	PollChanges(context.Context, *PollChangesRequest) (*PollChangesResponse, error)
	// SubscribeInbox creates a stream of new inbox messages.
	SubscribeInbox(*SubscribeInboxRequest, grpc.ServerStreamingServer[InboxMessage]) error
	// Publish sends a message to a pub/sub topic.
	Publish(context.Context, *PublishRequest) (*PublishResponse, error)
	// Subscribe subscribes an agent to a topic.
	Subscribe(context.Context, *SubscribeRequest) (*SubscribeResponse, error)
	// Unsubscribe removes an agent's subscription to a topic.
	Unsubscribe(context.Context, *UnsubscribeRequest) (*UnsubscribeResponse, error)
	// ListTopics lists available topics.
	ListTopics(context.Context, *ListTopicsRequest) (*ListTopicsResponse, error)
	// Search performs full-text search across messages.
	Search(context.Context, *SearchRequest) (*SearchResponse, error)
	// HasUnackedStatusTo checks if there are unacked status messages from
	// sender to recipient. Used for deduplication in status-update command.
	HasUnackedStatusTo(context.Context, *HasUnackedStatusToRequest) (*HasUnackedStatusToResponse, error)
	// ReplyToThread sends a reply message to an existing thread.
	ReplyToThread(context.Context, *ReplyToThreadRequest) (*ReplyToThreadResponse, error)
	// ArchiveThread archives all messages in a thread.
	ArchiveThread(context.Context, *ArchiveThreadRequest) (*ArchiveThreadResponse, error)
	// DeleteThread deletes all messages in a thread.
	DeleteThread(context.Context, *DeleteThreadRequest) (*DeleteThreadResponse, error)
	// MarkThreadUnread marks a thread as unread.
	MarkThreadUnread(context.Context, *MarkThreadUnreadRequest) (*MarkThreadUnreadResponse, error)
	// GetTopic retrieves a single topic by ID.
	GetTopic(context.Context, *GetTopicRequest) (*GetTopicResponse, error)
	// AutocompleteRecipients returns matching agents for autocomplete.
	AutocompleteRecipients(context.Context, *AutocompleteRecipientsRequest) (*AutocompleteRecipientsResponse, error)
	// DeleteMessage marks a message as deleted/trash.
	DeleteMessage(context.Context, *DeleteMessageRequest) (*DeleteMessageResponse, error)
	mustEmbedUnimplementedMailServer()
}

// UnimplementedMailServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMailServer struct{}

func (UnimplementedMailServer) SendMail(context.Context, *SendMailRequest) (*SendMailResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendMail not implemented")
}
func (UnimplementedMailServer) FetchInbox(context.Context, *FetchInboxRequest) (*FetchInboxResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FetchInbox not implemented")
}
func (UnimplementedMailServer) ReadMessage(context.Context, *ReadMessageRequest) (*ReadMessageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReadMessage not implemented")
}
func (UnimplementedMailServer) ReadThread(context.Context, *ReadThreadRequest) (*ReadThreadResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReadThread not implemented")
}
func (UnimplementedMailServer) UpdateState(context.Context, *UpdateStateRequest) (*UpdateStateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateState not implemented")
}
func (UnimplementedMailServer) AckMessage(context.Context, *AckMessageRequest) (*AckMessageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AckMessage not implemented")
}
func (UnimplementedMailServer) GetStatus(context.Context, *GetStatusRequest) (*GetStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetStatus not implemented")
}
func (UnimplementedMailServer) PollChanges(context.Context, *PollChangesRequest) (*PollChangesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PollChanges not implemented")
}
func (UnimplementedMailServer) SubscribeInbox(*SubscribeInboxRequest, grpc.ServerStreamingServer[InboxMessage]) error {
	return status.Errorf(codes.Unimplemented, "method SubscribeInbox not implemented")
}
func (UnimplementedMailServer) Publish(context.Context, *PublishRequest) (*PublishResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Publish not implemented")
}
func (UnimplementedMailServer) Subscribe(context.Context, *SubscribeRequest) (*SubscribeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Subscribe not implemented")
}
func (UnimplementedMailServer) Unsubscribe(context.Context, *UnsubscribeRequest) (*UnsubscribeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Unsubscribe not implemented")
}
func (UnimplementedMailServer) ListTopics(context.Context, *ListTopicsRequest) (*ListTopicsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListTopics not implemented")
}
func (UnimplementedMailServer) Search(context.Context, *SearchRequest) (*SearchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Search not implemented")
}
func (UnimplementedMailServer) HasUnackedStatusTo(context.Context, *HasUnackedStatusToRequest) (*HasUnackedStatusToResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HasUnackedStatusTo not implemented")
}
func (UnimplementedMailServer) ReplyToThread(context.Context, *ReplyToThreadRequest) (*ReplyToThreadResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReplyToThread not implemented")
}
func (UnimplementedMailServer) ArchiveThread(context.Context, *ArchiveThreadRequest) (*ArchiveThreadResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ArchiveThread not implemented")
}
func (UnimplementedMailServer) DeleteThread(context.Context, *DeleteThreadRequest) (*DeleteThreadResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteThread not implemented")
}
func (UnimplementedMailServer) MarkThreadUnread(context.Context, *MarkThreadUnreadRequest) (*MarkThreadUnreadResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MarkThreadUnread not implemented")
}
func (UnimplementedMailServer) GetTopic(context.Context, *GetTopicRequest) (*GetTopicResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTopic not implemented")
}
func (UnimplementedMailServer) AutocompleteRecipients(context.Context, *AutocompleteRecipientsRequest) (*AutocompleteRecipientsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AutocompleteRecipients not implemented")
}
func (UnimplementedMailServer) DeleteMessage(context.Context, *DeleteMessageRequest) (*DeleteMessageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteMessage not implemented")
}
func (UnimplementedMailServer) mustEmbedUnimplementedMailServer() {}
func (UnimplementedMailServer) testEmbeddedByValue()              {}

// UnsafeMailServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MailServer will
// result in compilation errors.
type UnsafeMailServer interface {
	mustEmbedUnimplementedMailServer()
}

func RegisterMailServer(s grpc.ServiceRegistrar, srv MailServer) {
	// If the following call pancis, it indicates UnimplementedMailServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Mail_ServiceDesc, srv)
}

func _Mail_SendMail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendMailRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MailServer).SendMail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mail_SendMail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MailServer).SendMail(ctx, req.(*SendMailRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mail_FetchInbox_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FetchInboxRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MailServer).FetchInbox(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mail_FetchInbox_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MailServer).FetchInbox(ctx, req.(*FetchInboxRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mail_ReadMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReadMessageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MailServer).ReadMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mail_ReadMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MailServer).ReadMessage(ctx, req.(*ReadMessageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mail_ReadThread_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReadThreadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MailServer).ReadThread(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mail_ReadThread_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MailServer).ReadThread(ctx, req.(*ReadThreadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mail_UpdateState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateStateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MailServer).UpdateState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mail_UpdateState_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MailServer).UpdateState(ctx, req.(*UpdateStateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mail_AckMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AckMessageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MailServer).AckMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mail_AckMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MailServer).AckMessage(ctx, req.(*AckMessageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mail_GetStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MailServer).GetStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mail_GetStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MailServer).GetStatus(ctx, req.(*GetStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mail_PollChanges_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PollChangesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MailServer).PollChanges(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mail_PollChanges_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MailServer).PollChanges(ctx, req.(*PollChangesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mail_SubscribeInbox_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeInboxRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(MailServer).SubscribeInbox(m, &grpc.GenericServerStream[SubscribeInboxRequest, InboxMessage]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Mail_SubscribeInboxServer = grpc.ServerStreamingServer[InboxMessage]

func _Mail_Publish_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PublishRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MailServer).Publish(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mail_Publish_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MailServer).Publish(ctx, req.(*PublishRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mail_Subscribe_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubscribeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MailServer).Subscribe(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mail_Subscribe_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MailServer).Subscribe(ctx, req.(*SubscribeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mail_Unsubscribe_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnsubscribeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MailServer).Unsubscribe(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mail_Unsubscribe_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MailServer).Unsubscribe(ctx, req.(*UnsubscribeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mail_ListTopics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListTopicsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MailServer).ListTopics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mail_ListTopics_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MailServer).ListTopics(ctx, req.(*ListTopicsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mail_Search_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MailServer).Search(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mail_Search_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MailServer).Search(ctx, req.(*SearchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mail_HasUnackedStatusTo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HasUnackedStatusToRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MailServer).HasUnackedStatusTo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mail_HasUnackedStatusTo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MailServer).HasUnackedStatusTo(ctx, req.(*HasUnackedStatusToRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mail_ReplyToThread_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReplyToThreadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MailServer).ReplyToThread(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mail_ReplyToThread_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MailServer).ReplyToThread(ctx, req.(*ReplyToThreadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mail_ArchiveThread_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ArchiveThreadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MailServer).ArchiveThread(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mail_ArchiveThread_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MailServer).ArchiveThread(ctx, req.(*ArchiveThreadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mail_DeleteThread_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteThreadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MailServer).DeleteThread(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mail_DeleteThread_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MailServer).DeleteThread(ctx, req.(*DeleteThreadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mail_MarkThreadUnread_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MarkThreadUnreadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MailServer).MarkThreadUnread(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mail_MarkThreadUnread_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MailServer).MarkThreadUnread(ctx, req.(*MarkThreadUnreadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mail_GetTopic_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTopicRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MailServer).GetTopic(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mail_GetTopic_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MailServer).GetTopic(ctx, req.(*GetTopicRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mail_AutocompleteRecipients_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AutocompleteRecipientsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MailServer).AutocompleteRecipients(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mail_AutocompleteRecipients_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MailServer).AutocompleteRecipients(ctx, req.(*AutocompleteRecipientsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Mail_DeleteMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteMessageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MailServer).DeleteMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Mail_DeleteMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MailServer).DeleteMessage(ctx, req.(*DeleteMessageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Mail_ServiceDesc is the grpc.ServiceDesc for Mail service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Mail_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "subtraterpc.Mail",
	HandlerType: (*MailServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SendMail",
			Handler:    _Mail_SendMail_Handler,
		},
		{
			MethodName: "FetchInbox",
			Handler:    _Mail_FetchInbox_Handler,
		},
		{
			MethodName: "ReadMessage",
			Handler:    _Mail_ReadMessage_Handler,
		},
		{
			MethodName: "ReadThread",
			Handler:    _Mail_ReadThread_Handler,
		},
		{
			MethodName: "UpdateState",
			Handler:    _Mail_UpdateState_Handler,
		},
		{
			MethodName: "AckMessage",
			Handler:    _Mail_AckMessage_Handler,
		},
		{
			MethodName: "GetStatus",
			Handler:    _Mail_GetStatus_Handler,
		},
		{
			MethodName: "PollChanges",
			Handler:    _Mail_PollChanges_Handler,
		},
		{
			MethodName: "Publish",
			Handler:    _Mail_Publish_Handler,
		},
		{
			MethodName: "Subscribe",
			Handler:    _Mail_Subscribe_Handler,
		},
		{
			MethodName: "Unsubscribe",
			Handler:    _Mail_Unsubscribe_Handler,
		},
		{
			MethodName: "ListTopics",
			Handler:    _Mail_ListTopics_Handler,
		},
		{
			MethodName: "Search",
			Handler:    _Mail_Search_Handler,
		},
		{
			MethodName: "HasUnackedStatusTo",
			Handler:    _Mail_HasUnackedStatusTo_Handler,
		},
		{
			MethodName: "ReplyToThread",
			Handler:    _Mail_ReplyToThread_Handler,
		},
		{
			MethodName: "ArchiveThread",
			Handler:    _Mail_ArchiveThread_Handler,
		},
		{
			MethodName: "DeleteThread",
			Handler:    _Mail_DeleteThread_Handler,
		},
		{
			MethodName: "MarkThreadUnread",
			Handler:    _Mail_MarkThreadUnread_Handler,
		},
		{
			MethodName: "GetTopic",
			Handler:    _Mail_GetTopic_Handler,
		},
		{
			MethodName: "AutocompleteRecipients",
			Handler:    _Mail_AutocompleteRecipients_Handler,
		},
		{
			MethodName: "DeleteMessage",
			Handler:    _Mail_DeleteMessage_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SubscribeInbox",
			Handler:       _Mail_SubscribeInbox_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "mail.proto",
}

const (
	Agent_RegisterAgent_FullMethodName   = "/subtraterpc.Agent/RegisterAgent"
	Agent_GetAgent_FullMethodName        = "/subtraterpc.Agent/GetAgent"
	Agent_ListAgents_FullMethodName      = "/subtraterpc.Agent/ListAgents"
	Agent_DeleteAgent_FullMethodName     = "/subtraterpc.Agent/DeleteAgent"
	Agent_UpdateAgent_FullMethodName     = "/subtraterpc.Agent/UpdateAgent"
	Agent_GetAgentsStatus_FullMethodName = "/subtraterpc.Agent/GetAgentsStatus"
	Agent_Heartbeat_FullMethodName       = "/subtraterpc.Agent/Heartbeat"
	Agent_EnsureIdentity_FullMethodName  = "/subtraterpc.Agent/EnsureIdentity"
	Agent_SaveIdentity_FullMethodName    = "/subtraterpc.Agent/SaveIdentity"
)

// AgentClient is the client API for Agent service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Agent is the RPC service for managing agent identities.
type AgentClient interface {
	// RegisterAgent creates a new agent with the given name.
	RegisterAgent(ctx context.Context, in *RegisterAgentRequest, opts ...grpc.CallOption) (*RegisterAgentResponse, error)
	// GetAgent retrieves an agent by ID or name.
	GetAgent(ctx context.Context, in *GetAgentRequest, opts ...grpc.CallOption) (*GetAgentResponse, error)
	// ListAgents lists all registered agents.
	ListAgents(ctx context.Context, in *ListAgentsRequest, opts ...grpc.CallOption) (*ListAgentsResponse, error)
	// DeleteAgent removes an agent by ID.
	DeleteAgent(ctx context.Context, in *DeleteAgentRequest, opts ...grpc.CallOption) (*DeleteAgentResponse, error)
	// UpdateAgent updates an agent's properties.
	UpdateAgent(ctx context.Context, in *UpdateAgentRequest, opts ...grpc.CallOption) (*UpdateAgentResponse, error)
	// GetAgentsStatus returns all agents with their status and counts.
	GetAgentsStatus(ctx context.Context, in *GetAgentsStatusRequest, opts ...grpc.CallOption) (*GetAgentsStatusResponse, error)
	// Heartbeat records a heartbeat for an agent.
	Heartbeat(ctx context.Context, in *HeartbeatRequest, opts ...grpc.CallOption) (*HeartbeatResponse, error)
	// EnsureIdentity creates or retrieves an agent identity for a session.
	EnsureIdentity(ctx context.Context, in *EnsureIdentityRequest, opts ...grpc.CallOption) (*EnsureIdentityResponse, error)
	// SaveIdentity persists an agent's current state.
	SaveIdentity(ctx context.Context, in *SaveIdentityRequest, opts ...grpc.CallOption) (*SaveIdentityResponse, error)
}

type agentClient struct {
	cc grpc.ClientConnInterface
}

func NewAgentClient(cc grpc.ClientConnInterface) AgentClient {
	return &agentClient{cc}
}

func (c *agentClient) RegisterAgent(ctx context.Context, in *RegisterAgentRequest, opts ...grpc.CallOption) (*RegisterAgentResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RegisterAgentResponse)
	err := c.cc.Invoke(ctx, Agent_RegisterAgent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentClient) GetAgent(ctx context.Context, in *GetAgentRequest, opts ...grpc.CallOption) (*GetAgentResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetAgentResponse)
	err := c.cc.Invoke(ctx, Agent_GetAgent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentClient) ListAgents(ctx context.Context, in *ListAgentsRequest, opts ...grpc.CallOption) (*ListAgentsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListAgentsResponse)
	err := c.cc.Invoke(ctx, Agent_ListAgents_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentClient) DeleteAgent(ctx context.Context, in *DeleteAgentRequest, opts ...grpc.CallOption) (*DeleteAgentResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteAgentResponse)
	err := c.cc.Invoke(ctx, Agent_DeleteAgent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentClient) UpdateAgent(ctx context.Context, in *UpdateAgentRequest, opts ...grpc.CallOption) (*UpdateAgentResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateAgentResponse)
	err := c.cc.Invoke(ctx, Agent_UpdateAgent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentClient) GetAgentsStatus(ctx context.Context, in *GetAgentsStatusRequest, opts ...grpc.CallOption) (*GetAgentsStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetAgentsStatusResponse)
	err := c.cc.Invoke(ctx, Agent_GetAgentsStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentClient) Heartbeat(ctx context.Context, in *HeartbeatRequest, opts ...grpc.CallOption) (*HeartbeatResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HeartbeatResponse)
	err := c.cc.Invoke(ctx, Agent_Heartbeat_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentClient) EnsureIdentity(ctx context.Context, in *EnsureIdentityRequest, opts ...grpc.CallOption) (*EnsureIdentityResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EnsureIdentityResponse)
	err := c.cc.Invoke(ctx, Agent_EnsureIdentity_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentClient) SaveIdentity(ctx context.Context, in *SaveIdentityRequest, opts ...grpc.CallOption) (*SaveIdentityResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SaveIdentityResponse)
	err := c.cc.Invoke(ctx, Agent_SaveIdentity_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AgentServer is the server API for Agent service.
// All implementations must embed UnimplementedAgentServer
// for forward compatibility.
//
// Agent is the RPC service for managing agent identities.
type AgentServer interface {
	// RegisterAgent creates a new agent with the given name.
	RegisterAgent(context.Context, *RegisterAgentRequest) (*RegisterAgentResponse, error)
	// GetAgent retrieves an agent by ID or name.
	GetAgent(context.Context, *GetAgentRequest) (*GetAgentResponse, error)
	// ListAgents lists all registered agents.
	ListAgents(context.Context, *ListAgentsRequest) (*ListAgentsResponse, error)
	// DeleteAgent removes an agent by ID.
	DeleteAgent(context.Context, *DeleteAgentRequest) (*DeleteAgentResponse, error)
	// UpdateAgent updates an agent's properties.
	UpdateAgent(context.Context, *UpdateAgentRequest) (*UpdateAgentResponse, error)
	// GetAgentsStatus returns all agents with their status and counts.
	GetAgentsStatus(context.Context, *GetAgentsStatusRequest) (*GetAgentsStatusResponse, error)
	// Heartbeat records a heartbeat for an agent.
	Heartbeat(context.Context, *HeartbeatRequest) (*HeartbeatResponse, error)
	// EnsureIdentity creates or retrieves an agent identity for a session.
	EnsureIdentity(context.Context, *EnsureIdentityRequest) (*EnsureIdentityResponse, error)
	// SaveIdentity persists an agent's current state.
	SaveIdentity(context.Context, *SaveIdentityRequest) (*SaveIdentityResponse, error)
	mustEmbedUnimplementedAgentServer()
}

// UnimplementedAgentServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedAgentServer struct{}

func (UnimplementedAgentServer) RegisterAgent(context.Context, *RegisterAgentRequest) (*RegisterAgentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterAgent not implemented")
}
func (UnimplementedAgentServer) GetAgent(context.Context, *GetAgentRequest) (*GetAgentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAgent not implemented")
}
func (UnimplementedAgentServer) ListAgents(context.Context, *ListAgentsRequest) (*ListAgentsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListAgents not implemented")
}
func (UnimplementedAgentServer) DeleteAgent(context.Context, *DeleteAgentRequest) (*DeleteAgentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteAgent not implemented")
}
func (UnimplementedAgentServer) UpdateAgent(context.Context, *UpdateAgentRequest) (*UpdateAgentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateAgent not implemented")
}
func (UnimplementedAgentServer) GetAgentsStatus(context.Context, *GetAgentsStatusRequest) (*GetAgentsStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAgentsStatus not implemented")
}
func (UnimplementedAgentServer) Heartbeat(context.Context, *HeartbeatRequest) (*HeartbeatResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Heartbeat not implemented")
}
func (UnimplementedAgentServer) EnsureIdentity(context.Context, *EnsureIdentityRequest) (*EnsureIdentityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EnsureIdentity not implemented")
}
func (UnimplementedAgentServer) SaveIdentity(context.Context, *SaveIdentityRequest) (*SaveIdentityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SaveIdentity not implemented")
}
func (UnimplementedAgentServer) mustEmbedUnimplementedAgentServer() {}
func (UnimplementedAgentServer) testEmbeddedByValue()               {}

// UnsafeAgentServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AgentServer will
// result in compilation errors.
type UnsafeAgentServer interface {
	mustEmbedUnimplementedAgentServer()
}

func RegisterAgentServer(s grpc.ServiceRegistrar, srv AgentServer) {
	// If the following call pancis, it indicates UnimplementedAgentServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Agent_ServiceDesc, srv)
}

func _Agent_RegisterAgent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterAgentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServer).RegisterAgent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Agent_RegisterAgent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServer).RegisterAgent(ctx, req.(*RegisterAgentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Agent_GetAgent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAgentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServer).GetAgent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Agent_GetAgent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServer).GetAgent(ctx, req.(*GetAgentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Agent_ListAgents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListAgentsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServer).ListAgents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Agent_ListAgents_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServer).ListAgents(ctx, req.(*ListAgentsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Agent_DeleteAgent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteAgentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServer).DeleteAgent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Agent_DeleteAgent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServer).DeleteAgent(ctx, req.(*DeleteAgentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Agent_UpdateAgent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateAgentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServer).UpdateAgent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Agent_UpdateAgent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServer).UpdateAgent(ctx, req.(*UpdateAgentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Agent_GetAgentsStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAgentsStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServer).GetAgentsStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Agent_GetAgentsStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServer).GetAgentsStatus(ctx, req.(*GetAgentsStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Agent_Heartbeat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HeartbeatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServer).Heartbeat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Agent_Heartbeat_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServer).Heartbeat(ctx, req.(*HeartbeatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Agent_EnsureIdentity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EnsureIdentityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServer).EnsureIdentity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Agent_EnsureIdentity_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServer).EnsureIdentity(ctx, req.(*EnsureIdentityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Agent_SaveIdentity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SaveIdentityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServer).SaveIdentity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Agent_SaveIdentity_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServer).SaveIdentity(ctx, req.(*SaveIdentityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Agent_ServiceDesc is the grpc.ServiceDesc for Agent service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Agent_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "subtraterpc.Agent",
	HandlerType: (*AgentServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RegisterAgent",
			Handler:    _Agent_RegisterAgent_Handler,
		},
		{
			MethodName: "GetAgent",
			Handler:    _Agent_GetAgent_Handler,
		},
		{
			MethodName: "ListAgents",
			Handler:    _Agent_ListAgents_Handler,
		},
		{
			MethodName: "DeleteAgent",
			Handler:    _Agent_DeleteAgent_Handler,
		},
		{
			MethodName: "UpdateAgent",
			Handler:    _Agent_UpdateAgent_Handler,
		},
		{
			MethodName: "GetAgentsStatus",
			Handler:    _Agent_GetAgentsStatus_Handler,
		},
		{
			MethodName: "Heartbeat",
			Handler:    _Agent_Heartbeat_Handler,
		},
		{
			MethodName: "EnsureIdentity",
			Handler:    _Agent_EnsureIdentity_Handler,
		},
		{
			MethodName: "SaveIdentity",
			Handler:    _Agent_SaveIdentity_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "mail.proto",
}

const (
	Session_ListSessions_FullMethodName    = "/subtraterpc.Session/ListSessions"
	Session_GetSession_FullMethodName      = "/subtraterpc.Session/GetSession"
	Session_StartSession_FullMethodName    = "/subtraterpc.Session/StartSession"
	Session_CompleteSession_FullMethodName = "/subtraterpc.Session/CompleteSession"
)

// SessionClient is the client API for Session service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Session is the RPC service for managing agent sessions.
type SessionClient interface {
	// ListSessions lists all sessions with optional filters.
	ListSessions(ctx context.Context, in *ListSessionsRequest, opts ...grpc.CallOption) (*ListSessionsResponse, error)
	// GetSession retrieves a single session by ID.
	GetSession(ctx context.Context, in *GetSessionRequest, opts ...grpc.CallOption) (*GetSessionResponse, error)
	// StartSession starts a new session for an agent.
	StartSession(ctx context.Context, in *StartSessionRequest, opts ...grpc.CallOption) (*StartSessionResponse, error)
	// CompleteSession marks a session as completed.
	CompleteSession(ctx context.Context, in *CompleteSessionRequest, opts ...grpc.CallOption) (*CompleteSessionResponse, error)
}

type sessionClient struct {
	cc grpc.ClientConnInterface
}

func NewSessionClient(cc grpc.ClientConnInterface) SessionClient {
	return &sessionClient{cc}
}

func (c *sessionClient) ListSessions(ctx context.Context, in *ListSessionsRequest, opts ...grpc.CallOption) (*ListSessionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListSessionsResponse)
	err := c.cc.Invoke(ctx, Session_ListSessions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sessionClient) GetSession(ctx context.Context, in *GetSessionRequest, opts ...grpc.CallOption) (*GetSessionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetSessionResponse)
	err := c.cc.Invoke(ctx, Session_GetSession_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sessionClient) StartSession(ctx context.Context, in *StartSessionRequest, opts ...grpc.CallOption) (*StartSessionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StartSessionResponse)
	err := c.cc.Invoke(ctx, Session_StartSession_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sessionClient) CompleteSession(ctx context.Context, in *CompleteSessionRequest, opts ...grpc.CallOption) (*CompleteSessionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CompleteSessionResponse)
	err := c.cc.Invoke(ctx, Session_CompleteSession_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SessionServer is the server API for Session service.
// All implementations must embed UnimplementedSessionServer
// for forward compatibility.
//
// Session is the RPC service for managing agent sessions.
type SessionServer interface {
	// ListSessions lists all sessions with optional filters.
	ListSessions(context.Context, *ListSessionsRequest) (*ListSessionsResponse, error)
	// GetSession retrieves a single session by ID.
	GetSession(context.Context, *GetSessionRequest) (*GetSessionResponse, error)
	// StartSession starts a new session for an agent.
	StartSession(context.Context, *StartSessionRequest) (*StartSessionResponse, error)
	// CompleteSession marks a session as completed.
	CompleteSession(context.Context, *CompleteSessionRequest) (*CompleteSessionResponse, error)
	mustEmbedUnimplementedSessionServer()
}

// UnimplementedSessionServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedSessionServer struct{}

func (UnimplementedSessionServer) ListSessions(context.Context, *ListSessionsRequest) (*ListSessionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListSessions not implemented")
}
func (UnimplementedSessionServer) GetSession(context.Context, *GetSessionRequest) (*GetSessionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSession not implemented")
}
func (UnimplementedSessionServer) StartSession(context.Context, *StartSessionRequest) (*StartSessionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartSession not implemented")
}
func (UnimplementedSessionServer) CompleteSession(context.Context, *CompleteSessionRequest) (*CompleteSessionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CompleteSession not implemented")
}
func (UnimplementedSessionServer) mustEmbedUnimplementedSessionServer() {}
func (UnimplementedSessionServer) testEmbeddedByValue()                 {}

// UnsafeSessionServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SessionServer will
// result in compilation errors.
type UnsafeSessionServer interface {
	mustEmbedUnimplementedSessionServer()
}

func RegisterSessionServer(s grpc.ServiceRegistrar, srv SessionServer) {
	// If the following call pancis, it indicates UnimplementedSessionServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Session_ServiceDesc, srv)
}

func _Session_ListSessions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListSessionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SessionServer).ListSessions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Session_ListSessions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SessionServer).ListSessions(ctx, req.(*ListSessionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Session_GetSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SessionServer).GetSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Session_GetSession_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SessionServer).GetSession(ctx, req.(*GetSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Session_StartSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SessionServer).StartSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Session_StartSession_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SessionServer).StartSession(ctx, req.(*StartSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Session_CompleteSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CompleteSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SessionServer).CompleteSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Session_CompleteSession_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SessionServer).CompleteSession(ctx, req.(*CompleteSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Session_ServiceDesc is the grpc.ServiceDesc for Session service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Session_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "subtraterpc.Session",
	HandlerType: (*SessionServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListSessions",
			Handler:    _Session_ListSessions_Handler,
		},
		{
			MethodName: "GetSession",
			Handler:    _Session_GetSession_Handler,
		},
		{
			MethodName: "StartSession",
			Handler:    _Session_StartSession_Handler,
		},
		{
			MethodName: "CompleteSession",
			Handler:    _Session_CompleteSession_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "mail.proto",
}

const (
	Activity_ListActivities_FullMethodName = "/subtraterpc.Activity/ListActivities"
)

// ActivityClient is the client API for Activity service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Activity is the RPC service for activity feeds.
type ActivityClient interface {
	// ListActivities lists activities with optional filters.
	ListActivities(ctx context.Context, in *ListActivitiesRequest, opts ...grpc.CallOption) (*ListActivitiesResponse, error)
}

type activityClient struct {
	cc grpc.ClientConnInterface
}

func NewActivityClient(cc grpc.ClientConnInterface) ActivityClient {
	return &activityClient{cc}
}

func (c *activityClient) ListActivities(ctx context.Context, in *ListActivitiesRequest, opts ...grpc.CallOption) (*ListActivitiesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListActivitiesResponse)
	err := c.cc.Invoke(ctx, Activity_ListActivities_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ActivityServer is the server API for Activity service.
// All implementations must embed UnimplementedActivityServer
// for forward compatibility.
//
// Activity is the RPC service for activity feeds.
type ActivityServer interface {
	// ListActivities lists activities with optional filters.
	ListActivities(context.Context, *ListActivitiesRequest) (*ListActivitiesResponse, error)
	mustEmbedUnimplementedActivityServer()
}

// UnimplementedActivityServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedActivityServer struct{}

func (UnimplementedActivityServer) ListActivities(context.Context, *ListActivitiesRequest) (*ListActivitiesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListActivities not implemented")
}
func (UnimplementedActivityServer) mustEmbedUnimplementedActivityServer() {}
func (UnimplementedActivityServer) testEmbeddedByValue()                  {}

// UnsafeActivityServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ActivityServer will
// result in compilation errors.
type UnsafeActivityServer interface {
	mustEmbedUnimplementedActivityServer()
}

func RegisterActivityServer(s grpc.ServiceRegistrar, srv ActivityServer) {
	// If the following call pancis, it indicates UnimplementedActivityServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Activity_ServiceDesc, srv)
}

func _Activity_ListActivities_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListActivitiesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ActivityServer).ListActivities(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Activity_ListActivities_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ActivityServer).ListActivities(ctx, req.(*ListActivitiesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Activity_ServiceDesc is the grpc.ServiceDesc for Activity service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Activity_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "subtraterpc.Activity",
	HandlerType: (*ActivityServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListActivities",
			Handler:    _Activity_ListActivities_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "mail.proto",
}

const (
	Stats_GetDashboardStats_FullMethodName = "/subtraterpc.Stats/GetDashboardStats"
	Stats_HealthCheck_FullMethodName       = "/subtraterpc.Stats/HealthCheck"
)

// StatsClient is the client API for Stats service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Stats is the RPC service for dashboard statistics.
type StatsClient interface {
	// GetDashboardStats returns dashboard statistics.
	GetDashboardStats(ctx context.Context, in *GetDashboardStatsRequest, opts ...grpc.CallOption) (*GetDashboardStatsResponse, error)
	// HealthCheck returns server health status.
	HealthCheck(ctx context.Context, in *HealthCheckRequest, opts ...grpc.CallOption) (*HealthCheckResponse, error)
}

type statsClient struct {
	cc grpc.ClientConnInterface
}

func NewStatsClient(cc grpc.ClientConnInterface) StatsClient {
	return &statsClient{cc}
}

func (c *statsClient) GetDashboardStats(ctx context.Context, in *GetDashboardStatsRequest, opts ...grpc.CallOption) (*GetDashboardStatsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetDashboardStatsResponse)
	err := c.cc.Invoke(ctx, Stats_GetDashboardStats_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *statsClient) HealthCheck(ctx context.Context, in *HealthCheckRequest, opts ...grpc.CallOption) (*HealthCheckResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HealthCheckResponse)
	err := c.cc.Invoke(ctx, Stats_HealthCheck_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// StatsServer is the server API for Stats service.
// All implementations must embed UnimplementedStatsServer
// for forward compatibility.
//
// Stats is the RPC service for dashboard statistics.
type StatsServer interface {
	// GetDashboardStats returns dashboard statistics.
	GetDashboardStats(context.Context, *GetDashboardStatsRequest) (*GetDashboardStatsResponse, error)
	// HealthCheck returns server health status.
	HealthCheck(context.Context, *HealthCheckRequest) (*HealthCheckResponse, error)
	mustEmbedUnimplementedStatsServer()
}

// UnimplementedStatsServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedStatsServer struct{}

func (UnimplementedStatsServer) GetDashboardStats(context.Context, *GetDashboardStatsRequest) (*GetDashboardStatsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDashboardStats not implemented")
}
func (UnimplementedStatsServer) HealthCheck(context.Context, *HealthCheckRequest) (*HealthCheckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HealthCheck not implemented")
}
func (UnimplementedStatsServer) mustEmbedUnimplementedStatsServer() {}
func (UnimplementedStatsServer) testEmbeddedByValue()               {}

// UnsafeStatsServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to StatsServer will
// result in compilation errors.
type UnsafeStatsServer interface {
	mustEmbedUnimplementedStatsServer()
}

func RegisterStatsServer(s grpc.ServiceRegistrar, srv StatsServer) {
	// If the following call pancis, it indicates UnimplementedStatsServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Stats_ServiceDesc, srv)
}

func _Stats_GetDashboardStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDashboardStatsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatsServer).GetDashboardStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Stats_GetDashboardStats_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatsServer).GetDashboardStats(ctx, req.(*GetDashboardStatsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Stats_HealthCheck_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HealthCheckRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StatsServer).HealthCheck(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Stats_HealthCheck_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StatsServer).HealthCheck(ctx, req.(*HealthCheckRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Stats_ServiceDesc is the grpc.ServiceDesc for Stats service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Stats_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "subtraterpc.Stats",
	HandlerType: (*StatsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetDashboardStats",
			Handler:    _Stats_GetDashboardStats_Handler,
		},
		{
			MethodName: "HealthCheck",
			Handler:    _Stats_HealthCheck_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "mail.proto",
}

const (
	ReviewService_CreateReview_FullMethodName      = "/subtraterpc.ReviewService/CreateReview"
	ReviewService_ListReviews_FullMethodName       = "/subtraterpc.ReviewService/ListReviews"
	ReviewService_GetReview_FullMethodName         = "/subtraterpc.ReviewService/GetReview"
	ReviewService_ResubmitReview_FullMethodName    = "/subtraterpc.ReviewService/ResubmitReview"
	ReviewService_CancelReview_FullMethodName      = "/subtraterpc.ReviewService/CancelReview"
	ReviewService_DeleteReview_FullMethodName      = "/subtraterpc.ReviewService/DeleteReview"
	ReviewService_ListReviewIssues_FullMethodName  = "/subtraterpc.ReviewService/ListReviewIssues"
	ReviewService_UpdateIssueStatus_FullMethodName = "/subtraterpc.ReviewService/UpdateIssueStatus"
)

// ReviewServiceClient is the client API for ReviewService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// ReviewService handles code review operations.
type ReviewServiceClient interface {
	// CreateReview creates a new review request.
	CreateReview(ctx context.Context, in *CreateReviewRequest, opts ...grpc.CallOption) (*CreateReviewResponse, error)
	// ListReviews lists reviews with optional filters.
	ListReviews(ctx context.Context, in *ListReviewsProtoRequest, opts ...grpc.CallOption) (*ListReviewsProtoResponse, error)
	// GetReview gets a single review with its iterations.
	GetReview(ctx context.Context, in *GetReviewProtoRequest, opts ...grpc.CallOption) (*ReviewDetailResponse, error)
	// ResubmitReview re-requests review after author changes.
	ResubmitReview(ctx context.Context, in *ResubmitReviewRequest, opts ...grpc.CallOption) (*CreateReviewResponse, error)
	// CancelReview cancels an active review.
	CancelReview(ctx context.Context, in *CancelReviewProtoRequest, opts ...grpc.CallOption) (*CancelReviewProtoResponse, error)
	// DeleteReview permanently removes a review and all associated data.
	DeleteReview(ctx context.Context, in *DeleteReviewProtoRequest, opts ...grpc.CallOption) (*DeleteReviewProtoResponse, error)
	// ListReviewIssues lists issues for a review.
	ListReviewIssues(ctx context.Context, in *ListReviewIssuesRequest, opts ...grpc.CallOption) (*ListReviewIssuesResponse, error)
	// UpdateIssueStatus updates the status of a review issue.
	UpdateIssueStatus(ctx context.Context, in *UpdateIssueStatusRequest, opts ...grpc.CallOption) (*UpdateIssueStatusResponse, error)
}

type reviewServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewReviewServiceClient(cc grpc.ClientConnInterface) ReviewServiceClient {
	return &reviewServiceClient{cc}
}

func (c *reviewServiceClient) CreateReview(ctx context.Context, in *CreateReviewRequest, opts ...grpc.CallOption) (*CreateReviewResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateReviewResponse)
	err := c.cc.Invoke(ctx, ReviewService_CreateReview_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reviewServiceClient) ListReviews(ctx context.Context, in *ListReviewsProtoRequest, opts ...grpc.CallOption) (*ListReviewsProtoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListReviewsProtoResponse)
	err := c.cc.Invoke(ctx, ReviewService_ListReviews_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reviewServiceClient) GetReview(ctx context.Context, in *GetReviewProtoRequest, opts ...grpc.CallOption) (*ReviewDetailResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReviewDetailResponse)
	err := c.cc.Invoke(ctx, ReviewService_GetReview_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reviewServiceClient) ResubmitReview(ctx context.Context, in *ResubmitReviewRequest, opts ...grpc.CallOption) (*CreateReviewResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateReviewResponse)
	err := c.cc.Invoke(ctx, ReviewService_ResubmitReview_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reviewServiceClient) CancelReview(ctx context.Context, in *CancelReviewProtoRequest, opts ...grpc.CallOption) (*CancelReviewProtoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CancelReviewProtoResponse)
	err := c.cc.Invoke(ctx, ReviewService_CancelReview_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reviewServiceClient) DeleteReview(ctx context.Context, in *DeleteReviewProtoRequest, opts ...grpc.CallOption) (*DeleteReviewProtoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteReviewProtoResponse)
	err := c.cc.Invoke(ctx, ReviewService_DeleteReview_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reviewServiceClient) ListReviewIssues(ctx context.Context, in *ListReviewIssuesRequest, opts ...grpc.CallOption) (*ListReviewIssuesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListReviewIssuesResponse)
	err := c.cc.Invoke(ctx, ReviewService_ListReviewIssues_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reviewServiceClient) UpdateIssueStatus(ctx context.Context, in *UpdateIssueStatusRequest, opts ...grpc.CallOption) (*UpdateIssueStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateIssueStatusResponse)
	err := c.cc.Invoke(ctx, ReviewService_UpdateIssueStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ReviewServiceServer is the server API for ReviewService service.
// All implementations must embed UnimplementedReviewServiceServer
// for forward compatibility.
//
// ReviewService handles code review operations.
type ReviewServiceServer interface {
	// CreateReview creates a new review request.
	CreateReview(context.Context, *CreateReviewRequest) (*CreateReviewResponse, error)
	// ListReviews lists reviews with optional filters.
	ListReviews(context.Context, *ListReviewsProtoRequest) (*ListReviewsProtoResponse, error)
	// GetReview gets a single review with its iterations.
	GetReview(context.Context, *GetReviewProtoRequest) (*ReviewDetailResponse, error)
	// ResubmitReview re-requests review after author changes.
	ResubmitReview(context.Context, *ResubmitReviewRequest) (*CreateReviewResponse, error)
	// CancelReview cancels an active review.
	CancelReview(context.Context, *CancelReviewProtoRequest) (*CancelReviewProtoResponse, error)
	// DeleteReview permanently removes a review and all associated data.
	DeleteReview(context.Context, *DeleteReviewProtoRequest) (*DeleteReviewProtoResponse, error)
	// ListReviewIssues lists issues for a review.
	ListReviewIssues(context.Context, *ListReviewIssuesRequest) (*ListReviewIssuesResponse, error)
	// UpdateIssueStatus updates the status of a review issue.
	UpdateIssueStatus(context.Context, *UpdateIssueStatusRequest) (*UpdateIssueStatusResponse, error)
	mustEmbedUnimplementedReviewServiceServer()
}

// UnimplementedReviewServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedReviewServiceServer struct{}

func (UnimplementedReviewServiceServer) CreateReview(context.Context, *CreateReviewRequest) (*CreateReviewResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateReview not implemented")
}
func (UnimplementedReviewServiceServer) ListReviews(context.Context, *ListReviewsProtoRequest) (*ListReviewsProtoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListReviews not implemented")
}
func (UnimplementedReviewServiceServer) GetReview(context.Context, *GetReviewProtoRequest) (*ReviewDetailResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetReview not implemented")
}
func (UnimplementedReviewServiceServer) ResubmitReview(context.Context, *ResubmitReviewRequest) (*CreateReviewResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResubmitReview not implemented")
}
func (UnimplementedReviewServiceServer) CancelReview(context.Context, *CancelReviewProtoRequest) (*CancelReviewProtoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelReview not implemented")
}
func (UnimplementedReviewServiceServer) DeleteReview(context.Context, *DeleteReviewProtoRequest) (*DeleteReviewProtoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteReview not implemented")
}
func (UnimplementedReviewServiceServer) ListReviewIssues(context.Context, *ListReviewIssuesRequest) (*ListReviewIssuesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListReviewIssues not implemented")
}
func (UnimplementedReviewServiceServer) UpdateIssueStatus(context.Context, *UpdateIssueStatusRequest) (*UpdateIssueStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateIssueStatus not implemented")
}
func (UnimplementedReviewServiceServer) mustEmbedUnimplementedReviewServiceServer() {}
func (UnimplementedReviewServiceServer) testEmbeddedByValue()                       {}

// UnsafeReviewServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ReviewServiceServer will
// result in compilation errors.
type UnsafeReviewServiceServer interface {
	mustEmbedUnimplementedReviewServiceServer()
}

func RegisterReviewServiceServer(s grpc.ServiceRegistrar, srv ReviewServiceServer) {
	// If the following call pancis, it indicates UnimplementedReviewServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ReviewService_ServiceDesc, srv)
}

func _ReviewService_CreateReview_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateReviewRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReviewServiceServer).CreateReview(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReviewService_CreateReview_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReviewServiceServer).CreateReview(ctx, req.(*CreateReviewRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReviewService_ListReviews_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListReviewsProtoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReviewServiceServer).ListReviews(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReviewService_ListReviews_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReviewServiceServer).ListReviews(ctx, req.(*ListReviewsProtoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReviewService_GetReview_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetReviewProtoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReviewServiceServer).GetReview(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReviewService_GetReview_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReviewServiceServer).GetReview(ctx, req.(*GetReviewProtoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReviewService_ResubmitReview_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResubmitReviewRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReviewServiceServer).ResubmitReview(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReviewService_ResubmitReview_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReviewServiceServer).ResubmitReview(ctx, req.(*ResubmitReviewRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReviewService_CancelReview_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelReviewProtoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReviewServiceServer).CancelReview(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReviewService_CancelReview_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReviewServiceServer).CancelReview(ctx, req.(*CancelReviewProtoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReviewService_DeleteReview_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteReviewProtoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReviewServiceServer).DeleteReview(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReviewService_DeleteReview_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReviewServiceServer).DeleteReview(ctx, req.(*DeleteReviewProtoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReviewService_ListReviewIssues_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListReviewIssuesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReviewServiceServer).ListReviewIssues(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReviewService_ListReviewIssues_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReviewServiceServer).ListReviewIssues(ctx, req.(*ListReviewIssuesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReviewService_UpdateIssueStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateIssueStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReviewServiceServer).UpdateIssueStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReviewService_UpdateIssueStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReviewServiceServer).UpdateIssueStatus(ctx, req.(*UpdateIssueStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ReviewService_ServiceDesc is the grpc.ServiceDesc for ReviewService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ReviewService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "subtraterpc.ReviewService",
	HandlerType: (*ReviewServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateReview",
			Handler:    _ReviewService_CreateReview_Handler,
		},
		{
			MethodName: "ListReviews",
			Handler:    _ReviewService_ListReviews_Handler,
		},
		{
			MethodName: "GetReview",
			Handler:    _ReviewService_GetReview_Handler,
		},
		{
			MethodName: "ResubmitReview",
			Handler:    _ReviewService_ResubmitReview_Handler,
		},
		{
			MethodName: "CancelReview",
			Handler:    _ReviewService_CancelReview_Handler,
		},
		{
			MethodName: "DeleteReview",
			Handler:    _ReviewService_DeleteReview_Handler,
		},
		{
			MethodName: "ListReviewIssues",
			Handler:    _ReviewService_ListReviewIssues_Handler,
		},
		{
			MethodName: "UpdateIssueStatus",
			Handler:    _ReviewService_UpdateIssueStatus_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "mail.proto",
}
